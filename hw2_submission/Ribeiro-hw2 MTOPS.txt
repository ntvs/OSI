import java.io.File;
import java.io.FileNotFoundException;
import java.util.*;



//************************************************************
//
// INTERFACE: SystemConstants
//
// Task performed
//    Contains all constants
//    This includes all errors, system settings, execution times, and fetch modes, PID/process offsets
//
// Input Parameters
//    None
//
// Output Parameters
//    None
//
// Function Return Value
//    None
//
//************************************************************
interface SystemConstants {

    //Settings
    public int WORDSIZE = 10000;
    public int GPRSIZE = 8;
    public long VALID_PROGRAM_AREA = 2999;
    public int DUMP_BOUND_L = 2990;
    public int DUMP_START = 230;

    //Memory blocks
    public long FREE_LIST_USER = 3000;
    public long FREE_LIST_USER_SIZE = 3999;
    public long FREE_LIST_OS = 7000;
    public long FREE_LIST_OS_SIZE = 3000;
    public long END_OF_LIST = -9999;

    //Fetch mode constants
    public long FETCH_REGISTER = 1;
    public long FETCH_REGISTER_DEFERRED = 2;
    public long FETCH_AUTO_INCREMENT = 3;
    public long FETCH_AUTO_DECREMENT = 4;
    public long FETCH_DIRECT = 5;
    public long FETCH_IMMEDIATE = 6;

    //Execution time constants
    public long TIME_HALT = 12;
    public long TIME_ADD = 3;
    public long TIME_SUBTRACT = 3;
    public long TIME_MULTIPLY = 6;
    public long TIME_DIVIDE = 6;
    public long TIME_MOVE = 2;
    public long TIME_BRANCH = 2;
    public long TIME_BRANCH_PLUS = 4;
    public long TIME_BRANCH_MINUS = 4;
    public long TIME_BRANCH_ZERO = 4;
    public long TIME_PUSH = 2;
    public long TIME_POP = 2;
    public long TIME_SYSTEM_CALL = 12; 

    //Error constants
    public long OK = 0;
    public long ERROR = -1;
    public long ERROR_UNKNOWN = -105;
    public long ERROR_INVALID_ADDRESS = -2;
    public long ERROR_INVALID_OPERANDS = -3;
    public long ERROR_INVALID_FETCH_MODE = -4;
    public long ERROR_IMMEDIATE_DESTINATION = -5;
    public long ERROR_FATAL_RUNTIME = -6;
    public long ERROR_INVALID_OPCODE = -7;
    public long ERROR_FILE_NOT_FOUND = -8;
    public long ERROR_FORMATTING = -9;
    public long ERROR_WORD_LENGTH = -10;
    public long ERROR_NO_FREE_MEMORY = -11;
    public long ERROR_INVALID_MEMORY_SIZE = -12;
    public long ERROR_TIME_EXPIRED = -13;

    //Proccess constants
    public long PROC_READY = 1;
    public long PROC_WAIT = 2;
    public long PROC_RUNNING = 3;
    
    public long DEFAULT_PRIORITY = 128;
    public int STACK_SIZE = 10;
    public long PROCESS_ID = 1; // This is actually not a constant, move it later to main
    public long TIME_SLICE = 200; //1; // Change this later

    //User mode constants
    public long MODE_USER = 2;
    public long MODE_OS = 1;

    //PCB constants
    public int PCB_LEN = 21;
    public int PCB_NEXT = 0;
    public int PCB_PID = 1;
    public int PCB_STATE = 2;
    public int PCB_REASON = 3;
    public int PCB_PRIORITY = 4;
    public int PCB_STACK_START = 5;
    public int PCB_STACK_SIZE = 6;
    public int PCB_MSGQ_START = 7;
    public int PCB_MSGQ_SIZE = 8;
    public int PCB_MSGQ_MESSAGES = 9;
    public int PCB_CONTEXT_GPR0 = 10;
    public int PCB_CONTEXT_GPR1 = 11;
    public int PCB_CONTEXT_GPR2 = 12;
    public int PCB_CONTEXT_GPR3 = 13;
    public int PCB_CONTEXT_GPR4 = 14;
    public int PCB_CONTEXT_GPR5 = 15;
    public int PCB_CONTEXT_GPR6 = 16;
    public int PCB_CONTEXT_GPR7 = 17;
    public int PCB_CONTEXT_SP = 18;
    public int PCB_CONTEXT_PC = 19;
    public int PCB_CONTEXT_PSR = 20;

    public long INT_NONE = 0;
    public long INT_RUN_PROGRAM = 1;
    public long INT_SHUTDOWN = 2;
    public long INT_INPUT_COMP = 3;
    public long INT_OUTPUT_COMP = 4;

}



//************************************************************
//
// CLASS: Main
//
// Task performed
//    The place where every method is called from and contains all hardware
//    Also has accessors and mutators to interact with the hardware
//
// Input Parameters
//    None
//
// Output Parameters
//    None
//
// Function Return Value
//    None
//
//************************************************************
public class Main {

    //Machine error/status variable (Separate from CPU error variable)
    private static long error;
    public static boolean on = true;

    //HARDWARE
    //Hypo main memory
    private static long[] hypoMemory; //Each word should contain a 6 integer value

    //Hypo memory registers
    private static long mar; //Memory address register
    private static long mbr; //Memory buffer register

    //Clock
    private static long clock;

    //CPU registers (GPR)
    private static long[] gpr;

    //CPU registers
    private static long ir; //Instruction register
    private static long psr; //Processor status register
    private static long pc; //Program counter
    private static long sp; //Stack pointer


    //FREE MEMORY SPACES
    private static long osFreeList = SystemConstants.END_OF_LIST;
    private static long userFreeList = SystemConstants.END_OF_LIST;

    //Waiting + Ready QUEUES
    private static long wq = SystemConstants.END_OF_LIST;
    private static long rq = SystemConstants.END_OF_LIST;
    
    //Process public vars
    public static long processID = 1;
    public static long runningPCBPointer;


    //************************************************************
    //
    // METHOD: Main
    //
    // Task performed
    //    Invokes initializeSystem() method to initialize all hardware values to 0
    //    Then creates CPU object and begins loop until machine is shut off
    //    Next, calls checkAndProcessInterrupt() method to allow user to choose what to do
    //    When shutdown interrupt is issued, indicate that the machine is shutting down and
    //    then exit the program
    //
    // Input Parameters
    //    None
    //
    // Output Parameters
    //    None
    //
    // Function Return Value
    //    None
    //
    //************************************************************
    public static void main(String[] args) {

        //Informational messages
        System.out.printf("%n%n[HYPO]");

        //Initialize everything to 0
        initializeSystem();
        
        //Instantiate a new CPU
        CPU cpu = new CPU();

        while (on) {

            // Check and process interrupt
            //call Check and Process Interrupt function and store return status
            long interruptID = SystemCall.checkAndProcessInterrupt();
            
            //if interrupt is shutdown, exit from main;
            if (interruptID == SystemConstants.INT_SHUTDOWN) {
                on = false;
                break;
            }

            // Dump RQ and WQ
            System.out.printf("%n%n[Dumping RQ and WQ before CPU scheduling]%n");
            SystemCall.printQueue(rq);
            System.out.printf("%n- - - - -%n");
            SystemCall.printQueue(wq);

            //Dumping memory before CPU scheduling
            dumpMemory("Dynamic Memory Area before CPU scheduling", SystemConstants.DUMP_BOUND_L, SystemConstants.DUMP_START);

            // Select next process from RQ to give CPU
            //Running PCB ptr = Select Process From RQ ();  // call the function
            runningPCBPointer = SystemCall.selectProcessFromRQ();

            // Perform restore context using Dispatcher
            //Call Dispatcher function with Running PCB ptr as argument;
            SystemCall.dispatcher(runningPCBPointer);

            //Dump RQ(“RQ: After selecting process from RQ\n”);
            System.out.printf("%n[Dumping RQ after selecting process]%n");
            SystemCall.printQueue(rq);

            //Dump Running PCB and CPU Context passing  Running PCB ptr as argument;
            if (runningPCBPointer != SystemConstants.END_OF_LIST) {
                SystemCall.printPCB(runningPCBPointer);

                // Execute instructions of the running process using the CPU
                //CPU Execute Program ();  // call the function
                long cpuStatus = cpu.cycle(); //Perform the CPU cycle
                //System.out.printf("%ncpuStatus return: %d%n", cpuStatus);

                // Dump dynamic memory area
                //Dump dynamic memory calling Dump Memory function(“After execute program\n”);
                String dumpAfterX = String.format("Dump of dynamic memory after %d CPU cycle(s) after executing program", cpu.getCycles());
                dumpMemory(dumpAfterX, SystemConstants.DUMP_BOUND_L, SystemConstants.DUMP_START);

                // Check return status – reason for giving up CPU
                if (cpuStatus == SystemConstants.ERROR_TIME_EXPIRED) {
                    
                    if (runningPCBPointer != SystemConstants.END_OF_LIST) {
                        //Save CPU Context of running process in its PCB;  // running process is losing CPU
                        SystemCall.saveContext(runningPCBPointer);

                        //Insert running process PCB into RQ;
                        SystemCall.insertIntoRQ(runningPCBPointer);

                        //Set Running PCB ptr = End Of List;
                        runningPCBPointer = SystemConstants.END_OF_LIST;
                    }
                
                } else if (cpu.getHaltStatus() || cpu.getErrorStatus() < 0) { // Halt or run-time error

                    if (runningPCBPointer != SystemConstants.END_OF_LIST) {
                        //Terminate running Process;
                        SystemCall.terminateProcess(runningPCBPointer);

                        //Set Running PCB ptr = End Of List;
                        runningPCBPointer = SystemConstants.END_OF_LIST;
                    }

                } else if (cpuStatus == SystemConstants.INT_INPUT_COMP) { // io_getc

                    if (runningPCBPointer != SystemConstants.END_OF_LIST) {
                        System.out.printf("%n<PID %d> GET_C system call issued. Process will stay in WQ until serviced.%n", Main.getHypoMemory(runningPCBPointer + SystemConstants.PCB_PID));
                        
                        SystemCall.saveContext(runningPCBPointer);

                        //Set reason for waiting in the running PCB to Input Completion Event;
                        setHypoMemory(runningPCBPointer + SystemConstants.PCB_REASON, SystemConstants.INT_INPUT_COMP);
                        
                        //Insert running process into WQ;
                        SystemCall.insertIntoWQ(runningPCBPointer);

                        //Set Running PCB ptr = End Of List;
                        runningPCBPointer = SystemConstants.END_OF_LIST;
                    }
                
                } else if (cpuStatus == SystemConstants.INT_OUTPUT_COMP) { // io_putc

                    if (runningPCBPointer != SystemConstants.END_OF_LIST) {
                        
                        System.out.printf("%n<PID %d> PUT_C system call issued. Process will stay in WQ until serviced.%n", Main.getHypoMemory(runningPCBPointer + SystemConstants.PCB_PID));

                        SystemCall.saveContext(runningPCBPointer);
                        
                        //Set reason for waiting in the running PCB to Input Completion Event;
                        setHypoMemory(runningPCBPointer + SystemConstants.PCB_REASON, SystemConstants.INT_OUTPUT_COMP);

                        //Insert running process into WQ;
                        SystemCall.insertIntoWQ(runningPCBPointer);

                        //Set Running PCB ptr = End Of List;
                        runningPCBPointer = SystemConstants.END_OF_LIST;
                    }
                
                } else { // Unknown programming error

                    //Display Unknown programming error message;
                    System.out.printf("%n[ERROR] The system has encountered an unknown programming error.%n");
                }

            } else {
                System.out.printf("%n[HYPO] No process running. Starting Null Process.%n");
                //SystemCall.createProcess("nullProc", 0);
            }

        }  // end of while not shutdown loop

        //Print OS is shutting down message;
        System.out.printf("%n[HYPO] The system is shutting down.%n");

        System.out.printf("%n%n");
    }


    //************************************************************
    // METHOD: InitializeSystem
    //
    // Task Description:
    //     Set all global system hardware components to 0 
    //     Set up free blocks and start null process
    //
    // Input Parameters
    //    None
    //
    // Output Parameters
    //    None
    //
    // Function Return Value
    //    None
    //************************************************************
    public static void initializeSystem() {
        
        //Initialize all machine hardware to 0
        error = 0;

        mar = 0;
        mbr = 0;
        clock = 0;
        ir = 0;
        psr = 0;
        pc = 0;
        sp = 0;

        //Set all memory and GPRs to 0
        hypoMemory = new long[SystemConstants.WORDSIZE];
        for (int i = 0; i < hypoMemory.length; i++) {
            hypoMemory[i] = 0;
        }

        gpr = new long[SystemConstants.GPRSIZE];
        for (int i = 0; i < gpr.length; i++) {
            gpr[i] = 0;
        }

        //Create User free list using the free block address and size given in the class
        // Set User Free List = start address given in the class
        userFreeList = SystemConstants.FREE_LIST_USER;

        // Set the next user free block pointer = End Of List
        hypoMemory[(int)userFreeList] = SystemConstants.END_OF_LIST;
        
        // Set second location in the free block = size of free block
        hypoMemory[(int)userFreeList+1] = SystemConstants.FREE_LIST_USER_SIZE;
        
        // Create OS free list using the free block address and size given in the class
        // Set OS Free List = start address given in the class
        osFreeList = SystemConstants.FREE_LIST_OS;

        // Set next OS free block pointer = End Of List
        hypoMemory[(int)osFreeList] = SystemConstants.END_OF_LIST;

        // Set second location in the free block = size of free block
        hypoMemory[(int)osFreeList+1] = SystemConstants.FREE_LIST_OS_SIZE;

        //wq = SystemConstants.END_OF_LIST;
        //rq = SystemConstants.END_OF_LIST;

        System.out.printf("%nSystem initialized...%n");

        //Start idle process
        SystemCall.createProcess("nullProc", 0);
    }


    //************************************************************
    // Function: DumpMemory
    //
    // Task Description:
    //    Displays a string passed as one of the  input parameter.
    //    Displays content of GPRs, SP, PC, PSR, system Clock and
    //    the content of specified memory locations in a specific format.
    //
    // Input Parameters
    //    String                String to be displayed
    //    StartAddress          Start address of memory location - First location to print
    //    Size                  Number of locations to dump
    // Output Parameters
    //    None            
    //
    // Function Return Value
    //    None                
    //************************************************************
    public static void dumpMemory(String inputParameterString, long startAddress, long size) {
        //inputParameterString = a string to print out when the dump occurs
        //startAddress = beginning address of memory to dump
        //size = used to calculate the last address of memory to dump

        //Calculate last address
        long addr = startAddress;
        long endAddress = startAddress + size;

        System.out.printf("%n========================================================================================");

        //State that a memory dump is occurring and state the input parameter string
        //Also print out "GPRs"
        System.out.printf("%n[MEMORY DUMP]%nInput parameter string: \"%s\"%n%n", inputParameterString);
        
        //Print GPR labels + SP AND PC labels
        System.out.printf("%-8s%-8s%-8s%-8s%-8s%-8s%-8s%-8s%-8s%-8s%-8s", "GPRs:", "G0", "G1", "G2", "G3", "G4", "G5", "G6", "G7", "SP", "PC");
        
        //Print values stored in the GPRs
        System.out.printf("%n%-8s%-8d%-8d%-8d%-8d%-8d%-8d%-8d%-8d%-8d%-8d", " ", gpr[0], gpr[1], gpr[2], gpr[3], gpr[4], gpr[5], gpr[6], gpr[7], sp, pc);

        System.out.printf("%n");
        
        //Print memory address labels
        System.out.printf("%n%-8s%-8s%-8s%-8s%-8s%-8s%-8s%-8s%-8s%-8s%-8s", "Addr:", "+0", "+1", "+2", "+3", "+4", "+5", "+6", "+7", "+8", "+9");
        
        //While the address is within the word size and within the end address
        while (addr < hypoMemory.length && addr < endAddress) {

            //Print the address number
            System.out.printf("%n%-8d", addr);
            String addressValues = "";
            
            //Attempt to print the next 10 address values
            for (int i = 0; i < 10; i++) {

                //If the address is less than the word size and less than
                //the end address, print it
                if (addr < hypoMemory.length && addr < endAddress) {
                    addressValues += String.format("%-8d", hypoMemory[(int)addr]);
                }
                //Increment the address no matter what, it should increment 10 times
                addr++;
            }

            //If the address is within the word size limit and the end address limit
            //print out its value
            System.out.printf(addressValues);
        }

        //Print clock and PSR values
        System.out.printf("%n%nClock: %d%nPSR: %d", clock, psr);

        System.out.printf("%n");

        System.out.printf("========================================================================================%n");

    }


    //************************************************************
    // ACCESSOR METHODS
    //
    // Task Description:
    //    Allows for retrieving values of private hardware variables with
    //    built-in validation
    //
    // Input Parameters
    //    getHypoMemory() - long location
    //    getGPR()        - long register
    //
    // Output Parameters
    //    None          
    //
    // Function Return Value
    //    all             - the value of the hardware
    //    getHypoMemory() - SystemConstants.ERROR_INVALID_ADDRESS
    //    getGPR()        - SystemConstants.ERROR_INVALID_ADDRESS                
    //************************************************************

    //This goes to a specified location in memory
    //And returns whatever is stored there if the location is valid
    public static long getHypoMemory(long location) {

        //Note that the isValidProgramArea method is not used.
        //This is because accessing memory outside the valid area may be needed
        if (location < hypoMemory.length && location > -1) {
            return hypoMemory[(int)location];
        } else {
            error = SystemConstants.ERROR_INVALID_ADDRESS;
            System.out.printf("%n$ ERROR %d: Location %d is greater than the word size or negative and cannot be accessed!%n", error, location);
            return error;
        }
    }

    //This goes to a specified GPR
    //And returns whatever is stored there if the GPR is valid
    public static long getGPR(long register) {
        if (register < gpr.length) {
            return gpr[(int)register];
        } else {
            error = SystemConstants.ERROR_INVALID_ADDRESS;
            System.out.printf("%n$ ERROR %d: GPR %d does not exist and cannot be accessed!%n", error, register);
            return error;
        }
    }

    public static long getMBR() {
        return mbr;
    }
    public static long getMAR() {
        return mar;
    }
    public static long getIR() {
        return ir;
    }
    public static long getSP() {
        return sp;
    }
    public static long getPSR() {
        return psr;
    }

    public static long getPC() {
        return pc;
    }

    public static long getOSFreeList() {
        return osFreeList;
    }
    public static long getUserFreeList() {
        return userFreeList;
    }
    public static long getWQ() {
        return wq;
    }
    public static long getRQ() {
        return rq;
    }


    //************************************************************
    // MUTATOR METHODS
    //
    // Task Description:
    //    Allows for setting values of private hardware variables with
    //    built-in validation
    //
    // Input Parameters
    //    all             - long value
    //    getHypoMemory() - long location, long instruction
    //    getGPR()        - long register, long value
    //
    // Output Parameters
    //    None          
    //
    // Function Return Value
    //    all             - void
    //    getHypoMemory() - SystemConstants.ERROR_INVALID_ADDRESS
    //    getGPR()        - SystemConstants.ERROR_INVALID_ADDRESS
    //    setPC()         - SystemConstants.ERROR_INVALID_ADDRESS
    //    incrementPC()   - SystemConstants.ERROR_INVALID_ADDRESS                
    //************************************************************
    public static void setError(long code) {
        error = code;
    }
    
    public static void setHypoMemory(long location, long instruction) {

        //Note that the isValidProgramArea method is not used.
        //This is because allocating memory outside the valid area may be needed
        if (location < hypoMemory.length && location > -1) {
            hypoMemory[(int)location] = instruction;
        } else {
            error = SystemConstants.ERROR_INVALID_ADDRESS;
            System.out.printf("%n$ ERROR %d: Location %d is greater than the word size and cannot be accessed!%n", error, location);
        }
    }

    public static void setGPR(long register, long value) {
        if (register < gpr.length) {
            gpr[(int)register] = value;
        } else {
            error = SystemConstants.ERROR_INVALID_ADDRESS;
            System.out.printf("%n$ ERROR %d: GPR %d does not exist and cannot be set!%n", error, register);
        }
    }

    public static void setMBR(long word) {
        mbr = word;
    }
    public static void setMAR(long word) {
        mar = word;
    }
    public static void setIR(long word) {
        ir = word;
    }
    public static void setPSR(long mode) {
        psr = mode;
    }
    public static void setSP(long pointer) {
        sp = pointer;
    }

    //Sets the program counter if the provided address is within the valid program area
    public static void setPC(long addr) {
        if (isValidProgramArea(addr)) {
            pc = addr;
        } else {
            error = SystemConstants.ERROR_INVALID_ADDRESS;
            pc = error;
            System.out.printf("%n$ ERROR %d: PC cannot be set to %d.%n", error, addr);
        }   
    }
    public static void incrementPC() {
        setPC(pc+1);
    }

    public static void incrementClock(long time) {
        clock += time;
    } 
    public static void incrementClock() {
        incrementClock(1);
    }

    public static void setOSFreeList(long addr) {
        osFreeList = addr;
    }
    public static void setUserFreeList(long addr) {
        userFreeList = addr;
    }
    public static void setWQ(long pointer) {
        wq = pointer;
    }
    public static void setRQ(long pointer) {
        rq = pointer;
    }


    //************************************************************
    // BOOLEAN METHODS
    //
    // Task Description:
    //    Checks if a given address is within the valid program area
    //
    // Input Parameters
    //    long addr
    //
    // Output Parameters
    //    None          
    //
    // Function Return Value
    //    true
    //    false             
    //************************************************************
    
    //Checks if addr is 0-2999
    public static boolean isValidProgramArea(long addr) {
        //return addr < SystemConstants.FREE_LIST_USER+SystemConstants.FREE_LIST_USER_SIZE+1 && addr > SystemConstants.FREE_LIST_USER-1;
        return addr < SystemConstants.FREE_LIST_USER && addr > -1;
    }
    
    //Checks if addr is 3000-6999
    public static boolean isUserMemory(long addr) {
        return addr < SystemConstants.FREE_LIST_USER + SystemConstants.FREE_LIST_USER_SIZE + 1 && addr > SystemConstants.FREE_LIST_USER -1;
    }

    //Checks if addr is 7000-10000
    public static boolean isOSMemory(long addr) {
        return addr < SystemConstants.FREE_LIST_OS + SystemConstants.FREE_LIST_OS_SIZE + 1 && addr > SystemConstants.FREE_LIST_OS -1;
    }
}



//************************************************************
//
// CLASS: AbsoluteLoader
//
// Task performed
//    Gets a filename thru user input or by manually setting the file path
//    Has a load method which loads that file into main memory and returns PC value 
//    if loaded successfully
//
// Input Parameters
//    Optional: file path in constructor
//
// Output Parameters
//    None
//
// Function Return Value
//    None
//
//************************************************************
class AbsoluteLoader {
    
    //SCANNERs - USER INPUT + FILE READER
    public Scanner input = new Scanner(System.in);
    public Scanner fileReader;

    private File programFile; //contains the program file

    //Constructors
    public AbsoluteLoader(String fileName) {
        //input.close();
        setFile(fileName);
    }
    public AbsoluteLoader() {
        System.out.printf("%n$ Enter program file name >>> ");
        String fileName = input.nextLine();
        input.close();

        setFile(fileName);
    }

    //Creates file object based on a provided string
    public void setFile(String fileName) {
        programFile = new File(fileName);
    }


    //********************************************************************
    // Function: load
    //
    // Task Description:
    //    Open the file containing HYPO machine user program and 
    //    load the content into HYPO memory.
    //    On successful load, return the PC value in the End of Program line.
    //    On failure, display appropriate error message and return appropriate error code
    //
    // Input Parameters
    //    filename from the instance variable
    //
    // Output Parameters
    //    None
    //
    // Function Return Value will be one of the following:
    //    ERROR_FILE_NOT_FOUND       Unable to open the file/not found
    //    ERROR_INVALID_ADDRESS      Invalid address error
    //    ERROR_WORD_LENGTH          Instruction or number exceeds 6 digits
    //    ERROR_FORMATTING           Line is not formatted correctly
    //    ErrorNoEndOfProgram        Missing end of program indicator
    //    0 - Valid address range    Successful Load, valid PC value
    //************************************************************
    public long load() {
        
        //Checks to see if file exits
        try {
            //If yes, proceed with scanning the file
            this.fileReader = new Scanner(programFile);
        } catch(FileNotFoundException e) {

            //If no, print the error
            System.out.printf("%n$ The file \"%s\" was not found.%n", programFile.getAbsolutePath());
            return SystemConstants.ERROR_FILE_NOT_FOUND;
        }

        int lineCount = 0; //Keeps track of how many lines read for error purposes

        //Read the file until there are no more lines
        while(fileReader.hasNextLine()) {
            String data = fileReader.nextLine(); //Grab the entire line
            String[] contents = data.split(" "); //Each line should have 2 values separated by a space. Split the line by a space
            
            //Check if line is in the correct format
            //If the array resulting from the split does not contain exactly 2 elements, the line is not formatted correctly
            if (contents.length == 2) {
                //The first element should be considered an address
                //The second element should be considered an instruction
                long addr = Long.parseLong(contents[0]);
                long instruction = Long.parseLong(contents[1]);

                //If the address is within the valid program area, go to that memory location and load the instruction
                //Otherwise if the address is -1 or lower, the end of the program has been reached
                if (Main.isValidProgramArea(addr)) {
                    
                    //Each instruction or number can only be a maximum of 6 digit. If not, the instruction is invalid
                    if(instruction > 999999) {
                        System.out.printf("%n$ The instruction at line %d is longer than 6 digits and the program was not loaded.%n", lineCount);
                        return SystemConstants.ERROR_WORD_LENGTH;
                    }

                    //Set the value of the specified memory address to the instruciton or number provided
                    Main.setHypoMemory(addr, instruction);

                //When the line reads -1, finish loading the program
                } else if(addr == -1) {
                    System.out.printf("%n$ End of program reached and program loaded successfully.%n");
                    return instruction;

                //Else, report invalid address error
                } else {
                    System.out.printf("%n$ Address %d in line %d is not valid!%n", addr, lineCount);
                    return SystemConstants.ERROR_INVALID_ADDRESS;
                }

            } else {
                System.out.printf("%n$ Line %d is not formatted correctly and the program was not loaded.%n", lineCount);
                return SystemConstants.ERROR_FORMATTING;
            }

            lineCount++; //Increment the line count
        }


        //Close file reader and return OK if there is no error
        fileReader.close();
        return SystemConstants.OK;
    } 
}



//************************************************************
//
// CLASS: CPU
//
// Task performed
//    Runs the program that has been loaded in main memory
//    Performs operations based on the program
//
// Input Parameters
//    None
//
// Output Parameters
//    None
//
// Function Return Value
//    None
//
//************************************************************
class CPU {
    
    //Instance variables
    private long cycles; //Holds the number of cycles that has occurred

    private boolean halt; //halt status
    private long error; //error status

    private long op1Value; //final value container of op 1 used for CPU operations
    private long op2Value; //final value container of op 2 used for CPU operations

    private long op1Address; //address container used to determine value 1
    private long op2Address; //address container used to determine value 2

    //Constructor - set everything to 0
    public CPU() {
        this.cycles = 0;
        this.halt = false;
        this.error = SystemConstants.OK;
        this.op1Value = 0;
        this.op2Value = 0;
        this.op1Address = 0;
        this.op2Address = 0;
    }


    //************************************************************
    // Function: cycle
    //
    // Task Description:
    //    Performs CPU cycles until an error occurs or halt is issued
    //    Executes the program in main memory
    //    It does this based on the final values of operands determined
    //    by the fetchOperand() method
    //    The CPU then adjust memory values accordingly.
    //
    // Input Parameters
    //    None
    //
    // Output Parameters
    //    None
    //
    // Function Return Value
    //    ERROR_IMMEDIATE_DESTINATION       Destination cannot be immediate value when writing
    //    ERROR_FATAL_RUNTIME               Division by 0
    //    ERROR_INVALID_OPCODE              Given CPU mode does not exist
    //    ERROR_INVALID_OPERANDS            op1Mode, op2Mode, op1GPR, or op2GPR are outside valid ranges
    //    ERROR_TIME_EXPIRED                CPU time over and CPU pauses
    //    ERROR_UNKNOWN                     Generic error/return value
    //************************************************************    
    public long cycle() {
        this.halt = false;
        long timeLeft = SystemConstants.TIME_SLICE;
        this.error = SystemConstants.OK;
        //long timeUsed = 0;

        //Cycle the CPU until state is set to halt or an error is set
        //Original condition: !halt && error >= 0
        //Debugging condition: !halt && error >= 0 && cycles < 1   <- specify the # of cycles you want
        while (!halt && error >= 0 && timeLeft > 0) {

            updateRegisters();
            
            long[] operands = parseOperands(); //Parse each digit from the 6 digit number in the IR
            //[0] = opCode
            //[1] = op1Mode
            //[2] = op1GPR
            //[3] = op2Mode
            //[4] = op2GPR

            if (operands[1] <= 6 && operands[3] <= 6 && operands[1] >= 0 && operands[3] >= 0 && operands[2] <= 8 && operands[4] <= 8 && operands[2] >= 0 && operands[4] >= 0) {
                
                long status;
                long result;
                long runningPCB;
                long runningPCBSP;
                long runningStack;

                switch ((int)operands[0]) {
                    
                    //Issue a halt: this mode will stop the CPU

                    case 0: //halt
                        this.halt = true;
                        System.out.printf("%n$ %d HALT: Halt encountered.%n", error);
                        Main.incrementClock(SystemConstants.TIME_HALT);
                        timeLeft -= SystemConstants.TIME_HALT;
                        break;


                    // MATH/MOVE MODES 1-5:
                    // Go to each one to read more
                    //
                    // 1: Addition
                    //
                    // 2: Subtraction
                    //
                    // 3: Multiplication
                    //
                    // 4: Division
                    //
                    // 5: MOVE

                    //Addition mode: Add value 1 and value 2 together after setting them.
                    // Then, based on what mode op1 is, write the difference to a location or discard it

                    case 1: //add
                        //Set value 1
                        status = fetchOperand(operands[1], operands[2], 1, 1);
                        if (status < 0) {
                            break;
                        }
                        //Set value 2
                        status = fetchOperand(operands[3], operands[4], 2, 2);
                        if (status < 0) {
                            break;
                        }
                        
                        //Add both values
                        result = this.op1Value + this.op2Value;

                        //If op1Mode = register mode
                        if (operands[1] == SystemConstants.FETCH_REGISTER) {

                            //Store the sum in the GPR specified by op1GPR
                            Main.setGPR(operands[2], result);
                        } else if (operands[1] == SystemConstants.FETCH_IMMEDIATE) {

                            //Do not store the sum anywhere and report an error
                            this.error = SystemConstants.ERROR_IMMEDIATE_DESTINATION;
                            System.out.printf("%n$ ERROR %d IMMEDIATE DESTINATION: Destination operand cannot be the immediate value when adding.%n", error);
                        } else {

                            //When in ANY other mode, store the sum in the address
                            //specified in the op1Address variable
                            Main.setHypoMemory(this.op1Address, result);
                        }
                        Main.incrementClock(SystemConstants.TIME_ADD);
                        timeLeft -= SystemConstants.TIME_ADD;
                        break;


                    //Subtraction mode: Subtract value 2 from value 1 after fetching them.
                    // Then, based on what mode op1 is, write the difference to a location or discard it

                    case 2: //subtract
                        //Set value 1
                        status = fetchOperand(operands[1], operands[2], 1, 1);
                        if (status < 0) {
                            break;
                        }
                        //Set value 2
                        status = fetchOperand(operands[3], operands[4], 2, 2);
                        if (status < 0) {
                            break;
                        }
                        
                        //Subtract value 2 from value 1
                        result = this.op1Value - this.op2Value;

                        //If op1Mode = register mode
                        if (operands[1] == SystemConstants.FETCH_REGISTER) {

                            //Store the difference in the GPR specified by op1GPR
                            Main.setGPR(operands[2], result);
                        } else if (operands[1] == SystemConstants.FETCH_IMMEDIATE) {

                            //Do not store the sum anywhere and report an error
                            this.error = SystemConstants.ERROR_IMMEDIATE_DESTINATION;
                            System.out.printf("%n$ ERROR %d IMMEDIATE DESTINATION: Destination operand cannot be the immediate value when subtracting.%n", error);
                        } else {

                            //When in ANY other mode, store the sum in the address
                            //specified in the op1Address variable
                            Main.setHypoMemory(this.op1Address, result);
                        }
                        Main.incrementClock(SystemConstants.TIME_SUBTRACT);
                        timeLeft -= SystemConstants.TIME_SUBTRACT;
                        break;
                    

                    //Multiplication mode: multiply value 1 by value 2 after fetching them.
                    // Then, based on what mode op1 is, write the result to a location or discard it

                    case 3: //multiply
                        //Set value 1
                        status = fetchOperand(operands[1], operands[2], 1, 1);
                        if (status < 0) {
                            break;
                        }
                        //Set value 1
                        status = fetchOperand(operands[3], operands[4], 2, 2);
                        if (status < 0) {
                            break;
                        }
                        
                        //Find their product
                        result = this.op1Value * this.op2Value;

                        //If op1Mode = register mode
                        if (operands[1] == SystemConstants.FETCH_REGISTER) {

                            //Store the result in the GPR specified by op1GPR
                            Main.setGPR(operands[2], result);
                        } else if (operands[1] == SystemConstants.FETCH_IMMEDIATE) {

                            //Do not store the result anywhere and report an error
                            this.error = SystemConstants.ERROR_IMMEDIATE_DESTINATION;
                            System.out.printf("%n$ ERROR %d IMMEDIATE DESTINATION: Destination operand cannot be the immediate value when multiplying.%n", error);
                        } else {

                            //When in ANY other mode, store the result in the address
                            //specified in the op1Address variable
                            Main.setHypoMemory(this.op1Address, result);
                        }
                        Main.incrementClock(SystemConstants.TIME_MULTIPLY);
                        timeLeft -= SystemConstants.TIME_MULTIPLY;
                        break;
                    

                    //Division mode: divide value 1 by value 2 after fetching them.
                    // Then, based on what mode op1 is, write the result to a location or discard it

                    case 4: //division
                        //Set value 1
                        status = fetchOperand(operands[1], operands[2], 1, 1);
                        if (status < 0) {
                            break;
                        }
                        //Set value 1
                        status = fetchOperand(operands[3], operands[4], 2, 2);
                        if (status < 0) {
                            break;
                        }

                        //Check value 2 for 0, as division by 0 is impossible
                        if (op2Value != 0) {
                            result = this.op1Value / this.op2Value;
                        } else {
                            this.error = SystemConstants.ERROR_FATAL_RUNTIME;
                            System.out.printf("%n$ FATAL RUNTIME ERROR %d: Cannot divide by zero.%n", error);
                            break;
                        }

                        //If op1Mode = register mode
                        if (operands[1] == SystemConstants.FETCH_REGISTER) {

                            //Store the result in the GPR specified by op1GPR
                            Main.setGPR(operands[2], result);
                        } else if (operands[1] == SystemConstants.FETCH_IMMEDIATE) {

                            //Do not store the result anywhere and report an error
                            this.error = SystemConstants.ERROR_IMMEDIATE_DESTINATION;
                            System.out.printf("%n$ ERROR %d IMMEDIATE DESTINATION: Destination operand cannot be the immediate value when dividing.%n", error);
                        } else {

                            //When in ANY other mode, store the result in the address
                            //specified in the op1Address variable
                            Main.setHypoMemory(this.op1Address, result);
                        }
                        Main.incrementClock(SystemConstants.TIME_DIVIDE);
                        timeLeft -= SystemConstants.TIME_DIVIDE;
                        break;
                    

                    //Move mode: set value 1 equal to whatever value 2 is after fetching them
                    // Then, based on what mode op1 is, write value 1 to a location or discard it

                    case 5: //move
                        //Set value 1
                        status = fetchOperand(operands[1], operands[2], 1, 1);
                        if (status < 0) {
                            break;
                        }
                        //Set value 2
                        status = fetchOperand(operands[3], operands[4], 2, 2);
                        if (status < 0) {
                            break;
                        }
                        
                        this.op1Value = this.op2Value;

                        //If op1Mode = register mode
                        if (operands[1] == SystemConstants.FETCH_REGISTER) {

                            //Store value 1 in the GPR specified by op1GPR
                            Main.setGPR(operands[2], this.op1Value);
                        } else if (operands[1] == SystemConstants.FETCH_IMMEDIATE) {

                            //Do not store value 1 anywhere and report an error
                            this.error = SystemConstants.ERROR_IMMEDIATE_DESTINATION;
                            System.out.printf("%n$ ERROR %d IMMEDIATE DESTINATION: Destination operand cannot be the immediate value when moving.%n", error);
                        } else {

                            //When in ANY other mode, store value 1 in the address
                            //specified in the op1Address variable
                            Main.setHypoMemory(this.op1Address, this.op1Value);
                        }
                        Main.incrementClock(SystemConstants.TIME_MOVE);
                        timeLeft -= SystemConstants.TIME_MOVE;
                        break;


                    // BRANCH MODES 6-9
                    // 
                    // 6: Assumes 1 input - looks at the value stored at the memory address that the PC is pointing to
                    //      - So it will look at the next line and assume a memory address is stored there
                    //      - Then it will jump to the memory location specified
                    //
                    // 7: Looks at the value of operand 1 & value stored at memory address that PC points to
                    //      - One of the next lines must specify an address to jump to
                    //      - IF value 1 is negative and nonzero, reset the PC to a specified value
                    //      - otherwise, skip the next line and proceed
                    //
                    // 8: Looks at the value of operand 1 & value stored at memory address that PC points to
                    //      - One of the next lines must specify an address to jump to
                    //      - IF value 1 is positive and nonzero, reset the PC to a specified value
                    //      - otherwise, skip the next line and proceed
                    //
                    // 9: Looks at the value of operand 1 & value stored at memory address that PC points to
                    //      - One of the next lines must specify an address to jump to
                    //      - IF value 1 is ZERO, reset the PC to a specified value
                    //      - otherwise, skip the next line and proceed

                    case 6: //branch/jump instruction
                        //Set the PC to the next value in the memory address that the PC points too
                        Main.setPC(Main.getHypoMemory(Main.getPC()));
                        Main.incrementClock(SystemConstants.TIME_BRANCH);
                        timeLeft -= SystemConstants.TIME_BRANCH;
                        break;

                    case 7: //branch on minus
                        //Set value 1 and only value 1 - NOT both values
                        status = fetchOperand(operands[1], operands[2], 1, 1);
                        if (status < 0) {
                            break;
                        }
                        
                        //This assumes that the next line contains an address
                        // If value 1 is negative and nonzero
                        if (this.op1Value < 0) {
                            //Go to the next line and get that address
                            //THEN set the PC to that address
                            Main.setPC(Main.getHypoMemory(Main.getPC()));
                        } else {
                            //Otherwise, skip the next line and proceed
                            Main.incrementPC();
                        }
                        Main.incrementClock(SystemConstants.TIME_BRANCH_MINUS);
                        timeLeft -= SystemConstants.TIME_BRANCH_MINUS;
                        break;

                    case 8: //branch on plus
                        //Set value 1 and only value 1 - NOT both values
                        status = fetchOperand(operands[1], operands[2], 1, 1);
                        if (status < 0) {
                            break;
                        }

                        //This assumes that the next line contains an address
                        // If value 1 is positive and nonzero
                        if (this.op1Value > 0) {

                            //Go to the next line and assume it contains an address
                            //get that address
                            //THEN set the PC to that address
                            //This is the location the program will jump to
                            //if value 1 is positive and nonzero
                            Main.setPC(Main.getHypoMemory(Main.getPC()));
                        } else {

                            //Otherwise, skip the next line and proceed
                            Main.incrementPC();
                        }
                        Main.incrementClock(SystemConstants.TIME_BRANCH_PLUS);
                        timeLeft -= SystemConstants.TIME_BRANCH_PLUS;
                        break;

                    case 9: //branch on zero
                        //Set value 1 and only value 1 - NOT both values
                        status = fetchOperand(operands[1], operands[2], 1, 1);
                        if (status < 0) {
                            break;
                        }

                        //This assumes that the next line contains an address
                        // If value 1 IS ZERO
                        if (this.op1Value == 0) {

                            //Go to the next line and get that address
                            //THEN set the PC to that address
                            Main.setPC(Main.getHypoMemory(Main.getPC()));
                        } else {
                            //Otherwise, skip the next line and proceed
                            Main.incrementPC();
                        }
                        Main.incrementClock(SystemConstants.TIME_BRANCH_ZERO);
                        timeLeft -= SystemConstants.TIME_BRANCH_ZERO;
                        break;


                    // STACK MODES 10-11 - not yet implemented
                    // 
                    // 10. Pushes op1Value to process stack. Does not check for overflow
                    //
                    // 11. Pops process stack top value into op1Value. Does not check for underflow
                    //

                    case 10: //push if stack is not full
                        status = fetchOperand(operands[1], operands[2], 1, 1);
                        if (status < 0) {
                            break;
                        }
                        //System.out.printf("%n$ Case 10: push to stack.%n");

                        //Get PCB of running process
                        runningPCB = Main.runningPCBPointer;

                        //Pointer to location in PCB that contains the address of the stack
                        runningPCBSP = runningPCB + SystemConstants.PCB_STACK_START;

                        //Pointer to actual stack
                        runningStack = Main.getHypoMemory(runningPCBSP);

                        //Push value to stack location
                        Main.setHypoMemory(runningStack, this.op1Value);

                        //Move the stack pointer along
                        Main.setHypoMemory(runningPCBSP, runningStack+1);
                        
                        System.out.printf("%nCase 10 > Pushing %d to location %d.%n", this.op1Value, runningStack);


                        Main.incrementClock(SystemConstants.TIME_PUSH);
                        timeLeft -= SystemConstants.TIME_PUSH;

                        break;
                    
                    case 11: //pop if stack is not empty
                        /*status = fetchOperand(operands[1], operands[2], 1, 1);
                        if (status < 0) {
                            break;
                        }*/
                        //System.out.printf("%n$ Case 11: pop from stack.%n");

                        runningPCB = Main.runningPCBPointer;

                        //Pointer to location in PCB that contains the address of the stack
                        runningPCBSP = runningPCB + SystemConstants.PCB_STACK_START;


                        //Pointer to actual stack
                        runningStack = Main.getHypoMemory(runningPCBSP)-1;

                        //Move the stack pointer back
                        Main.setHypoMemory(runningPCBSP, runningStack);

                        //Store popped value in op1Value
                        this.op1Value = Main.getHypoMemory(runningStack);

                        System.out.printf("%nCase 11 > Popping %d from location %d.%n", this.op1Value, runningStack);


                        Main.incrementClock(SystemConstants.TIME_POP);
                        timeLeft -= SystemConstants.TIME_POP;

                        break;


                    // SYSTEM MODE 12 - System Call
                    // 
                    // Can be used to (de)allocate memory, set clock, and get/print characters
                    //

                    case 12:
                        //Set value 1
                        status = fetchOperand(operands[1], operands[2], 1, 1);
                        if (status < 0) {
                            break;
                        }

                        status = systemCall(op1Value);

                        if (status == SystemConstants.INT_INPUT_COMP || status == SystemConstants.INT_OUTPUT_COMP) {
                            this.error = status;
                            return this.error;
                        }
                        
                        Main.incrementClock(SystemConstants.TIME_SYSTEM_CALL);
                        timeLeft -= SystemConstants.TIME_SYSTEM_CALL;

                        break;
                    
                    default:
                        this.error = SystemConstants.ERROR_INVALID_OPCODE;
                        System.out.printf("%n$ ERROR %d INVALID OPCODE: Opcode %d does not exist.%n", error, operands[0]);
                        break;
                }


            } else {
                this.error = SystemConstants.ERROR_INVALID_OPERANDS;
                System.out.printf("%n$ ERROR %d INVALID OPERANDS: One of the operands contain an invalid mode or attempts to access an invalid GPR number.%n", error);
            }

            this.cycles++;

            //DEBUGGING
            //this.halt = true;
            //printOperands(operands);
            
            //String cycleNumber = String.format("Cycle number %d", cycles);
            //Main.dumpMemory(cycleNumber, 0, 100);
            //System.out.printf("%nTimeLeft: %d%n", timeLeft);
        }

        //System.out.printf("%nHaltStatus: %b%n", this.halt);
        //System.out.printf("%nErrorCode: %d%n", this.error);

        if (timeLeft < 1) {
            return SystemConstants.ERROR_TIME_EXPIRED;
        } else {
            return SystemConstants.ERROR_UNKNOWN;
        }

    }


    //************************************************************
    // Function: systemCall
    //
    // Task Description:
    //    Switch statement that decides which system call to execute
    //
    // Input Parameters
    //    long systemCallID
    //
    // Output Parameters
    //    long status
    //
    // Function Return Value
    //    OK                                Normal
    //    ERROR_INVALID_MEMORY_SIZE         Invalid memory block size requested
    //    ERROR_NO_FREE_MEMORY              No free block available in the UFL
    //    ERROR_INVALID_ADDRESS             Invalid size/memory block outside user memory range when attempting to free user memory
    //    -                                 Pointer outside of user memory range when attempting to free user memory
    //    INT_INPUT_COMP                    Start of input operation event code
    //    INT_OUTPUT_COMP                   Start of output operation event code
    //************************************************************   
    long systemCall(long systemCallID) {

        long status = SystemConstants.OK;

        Main.setPSR(SystemConstants.MODE_OS); //Set the system mode to OS mode

        switch((int)systemCallID) {

            //Create a process
            //when user process is creating a child process
            case 1:
                System.out.printf("%n$ System Call ID 1: Create process not implemented.%n");
                break;
            
            //Delete a process
            case 2:
                System.out.printf("%n$ System Call ID 2: Delete process not implemented.%n");
                break;
            
            //Process inquiry - info about a process
            case 3: 
                System.out.printf("%n$ System Call ID 3: Process inquiry not implemented.%n");
                break;

            //Dynamic user memory allocation
            //Allocating free memory to the user
            case 4: 
                status = SystemCall.MemAlloc();
                break;

            //Dynamic user memory deallocation
            //Freeing memory for the user
            case 5:
                status = SystemCall.MemFree();
                break;

            //Process message sending - send message from one process to another
            case 6:
                System.out.printf("%n$ System Call ID 6: Process message sending not implemented.%n");
                break;

            //Process message receiving - receive message from another process
            case 7:
                System.out.printf("%n$ System Call ID 7: Process message receiving not implemented.%n");
                break;
            
            //io_getc  system call
            //Accept input of one character from the keyboard
            case 8: 
                status = SystemCall.io_getcSystemCall();
                break;

            // io_putc system call
            //Print one stored character at a time
            case 9:
                status = SystemCall.io_putcSystemCall();
                break;

            //time_get
            //retrieve CPU clock value and store in GPR1; GPR0 = OK
            case 10:
                SystemCall.time_get();
                break;
            
            //time_set
            //set CPU clock to whatever is in GPR1; GPR0 = OK
            case 11:
                SystemCall.time_set();
                break;

            default:
                System.out.printf("%n$ ERROR %d: The requested system call is invalid and does not exist.%n", SystemConstants.ERROR);
                break;
        }

        Main.setPSR(SystemConstants.MODE_USER); //Set the system mode back to user mode

        return status;
    }

    //************************************************************
    // Function: updateRegisters
    //
    // Task Description:
    //    Updates MAR, MBR, IR, and PC at the beginning of every CPU cycle
    //
    // Input Parameters
    //    None
    //
    // Output Parameters
    //    None
    //
    // Function Return Value
    //    ERROR_INVALID_ADDRESS         Program counter contains an invalid address
    //************************************************************
    public void updateRegisters() {
        long programCounter = Main.getPC();

        //Proceed only if 0 <= PC <= 10000 - Non negative and within the valid program area
        if (0 <= programCounter && programCounter <= SystemConstants.WORDSIZE) {

            Main.setMAR(programCounter); //set MAR to the value of the PC
            Main.incrementPC(); //PC now contains the addr of the next word while MAR has the current word

            long word = Main.getHypoMemory(Main.getMAR()); //Retrieve word from memory using address stored in MAR
            Main.setMBR(word); //Load the word into the MBR

        } else {
            this.error = SystemConstants.ERROR_INVALID_ADDRESS;
            System.out.printf("%n$ ERROR %d INVALID ADDRESS: The program counter points to a negative address or an address outside the valid program area.%n", error);
        }

        Main.setIR(Main.getMBR()); //Get the MBR value and store it in the IR
    }


    //************************************************************
    // Function: parseOperands
    //
    // Task Description:
    //    Splits 5-6 digit line from the IR into an array of 5 separate values
    //
    // Input Parameters
    //    Main class IR instance variable
    //
    // Output Parameters
    //    None
    //
    // Function Return Value
    //    long[] operands
    //************************************************************
    public long[] parseOperands() {
        //Separate the opcode from the word and leave the rest in remainder
        //Opcode tells CPU what mode it should be in
        long opCode = (Main.getIR()) / 10000; //extracts the first digit from the word. example: 15060 / 10000 = 1.506 = opCode 1
        long remainder = (Main.getIR()) % 10000; //extracts everything else except the first digit... so 5060

        //Extract information about the operands... for example, in 5060, op1=50 op2=60
        //Each one of the operands are split into 2 parts, first digit being the "mode" for that operand 
        //Second digit of the operand is one of the GPRs (or usually 0 if a GPR is not used in that instance)

        //Mathematically extract the first digit of op1 (op1Mode)
        long op1Mode = remainder / 1000;
        remainder = remainder % 1000;

        //Mathematically extract the second digit of op1 (op1GPR)
        long op1GPR = remainder / 100;
        remainder = remainder % 100;

        //Mathematically extract the first digit of op2 (op2Mode)
        long op2Mode = remainder / 10;
        remainder = remainder % 10;

        //Mathematically extract the second digit of op2 (op2GPR)
        long op2GPR = remainder / 1;

        //Return all the operands as an array
        long[] operands = {opCode, op1Mode, op1GPR, op2Mode, op2GPR};

        return operands;
    }


    //************************************************************
    // Function: printOperands
    //
    // Task Description:
    //    Simple array printing method to print the array of operands for debugging
    //
    // Input Parameters
    //    long[] operands
    //
    // Output Parameters
    //    None
    //
    // Function Return Value
    //    None
    //************************************************************
    public void printOperands(long[] operands) {
        System.out.printf("%nOperands array: ");
        for (int i = 0; i < 5; i++) {
            System.out.printf("%d ", operands[i]);
        }
        System.out.printf("%n");
    }
    

    //************************************************************
    // Function: FetchOperand
    //
    // Task Description:
    //    Method/switch statement that can set op value 1 or op value 2 that 
    //    the CPU uses for operations based on the mode passed into it
    //
    // Input Parameters
    //    mode          long describing which fetch mode to use
    //    gpr           long describing which GPR to access
    //    operandAddr   integer describing which address variable to access, 1 or 2
    //    operandValue  integer describing which value variable to access, 1 or 2
    // Output Parameters
    //    op1Address/op2Address     Address container used to determine value 1 or 2
    //    op1Value/op2Value         Final value container of op 1 or 2 used for CPU operations
    //
    // Function Return Value
    //    OK                        On successful fetch
    //    ERROR_INVALID_ADDRESS     Attempts to set or access invalid memory address
    //    ERROR_INVALID_FETCH_MODE  Fetch mode does not exist
    //************************************************************
    public long fetchOperand(long mode, long gpr, int operandAddr, int operandValue) {
        //mode: long describing which fetch mode to use
        //gpr: long describing which GPR to access
        //operandAddr: integer describing which address variable to access, 1 or 2
        //operandValue: integer describing which value variable to access, 1 or 2

        switch((int)mode) {
            
            // GPR MODES 1-4: these modes deal with GPRs
            //
            // 1: Read and write to a GPR when performing math operations or moves (op1)
            //
            // 2: A GPR contains a memory location. Retrieve your value from there
            //      - Read and write to that location when performing math operations or moves (op1)
            //
            // 3: A GPR contains a memory location. Retrieve your value from there
            //      - Read and write to that location when performing math operations or moves (op1)
            //      - Increment that GPR's value after using it
            //
            // 4: A GPR contains a memory location. Retrieve your value from there
            //      - Read and write to that location when performing math operations or moves (op1)
            //      - Decrement that GPR's value after using it

            //Register mode: This mode retrieves from a GPR but will also lock you into writing 
            //to the same GPR for the current cycle (op1).

            case 1: //register mode - This mode will go to the specified GPR and retrieve its value
                setOpAddress(operandAddr, -200); //Set the specified op address var to a negative num
                
                //Set the specified op value var to the value that is in the specified GPR
                setOpValue(operandValue, Main.getGPR(gpr));
                break;


            //Register deferred mode: This mode retrieves a location from a GPR 
            //but will also lock you into writing to the same memory location for the current cycle (op1).
            //Use it when you want to fetch a memory location from a GPR

            case 2: //register deferred mode - "Op addr in GPR and value in memory"
                
                //In this case, there is something inside the GPR specified by the var gpr
                //Retrieve that value
                //Put it inside op address 1 or 2
                setOpAddress(operandAddr, Main.getGPR(gpr));

                //When in fetch mode 2, the assumption is that the
                //specified GPR contains another memory location...
                if (Main.isValidProgramArea(getOpAddress(operandAddr))) {

                    //Go to the memory address that the GPR points to
                    //Get whatever is stored there and set it as value either 1 or 2
                    setOpValue(operandValue, Main.getHypoMemory(operandAddr));
                } else {
                    this.error = SystemConstants.ERROR_INVALID_ADDRESS;
                    System.out.printf("%n$ ERROR %d INVALID ADDRESS: GPR %d is invalid in case 2.%n", error, operandAddr);
                    return this.error;
                }
                break;


            //Autoincrement mode: SAME AS MODE 2 - This mode retrieves a location from a GPR 
            //but will also lock you into writing to the same memory location for the current cycle (op1).
            //Use it when you want to fetch a memory location from a GPR

            //However, after retrieving an address from said GPR, move the contained address to the one after it
            //So now the GPR will contain the address directly after the address it previously contained

            case 3: //autoincrement mode (Op addr in GPR and value in memory)
                
                //In this case, there is something inside the GPR specified by the var gpr
                //Retrieve that value
                //Put it inside op address 1 or 2
                setOpAddress(operandAddr, Main.getGPR(gpr));

                //When in fetch mode 3, the assumption is that the
                //specified GPR contains another memory location...
                if (Main.isUserMemory(getOpAddress(operandAddr))) { //isValidProgramArea

                    //Go to the memory address that the GPR points to
                    //Get whatever is stored there and set it as value either 1 or 2
                    setOpValue(operandValue, Main.getHypoMemory(getOpAddress(operandAddr)));

                    //Now, increment the value of that GPR by 1
                    //So essentially, move the address contained by the GPR to the next address after it
                    Main.setGPR(gpr, (Main.getGPR(gpr))+1);

                } else {
                    this.error = SystemConstants.ERROR_INVALID_ADDRESS;
                    System.out.printf("%n$ ERROR %d INVALID ADDRESS: GPR %d is invalid in case 3.%n", error, operandAddr);
                }
                break;


            //Autodecrement mode: SAME AS MODE 3 - This mode retrieves a location from a GPR 
            //but will also lock you into writing to the same memory location for the current cycle (op1).
            //Use it when you want to fetch a memory location from a GPR

            //However, after retrieving an address from said GPR, move the contained address to the one before it
            //So now the GPR will contain the address directly before the address it previously contained

            case 4: //autodecrement mode 
                Main.setGPR(gpr, (Main.getGPR(gpr))-1); //decrement register value by 1

                //In this case, there is something inside the GPR specified by the var gpr
                //Retrieve that value
                //Put it inside op address 1 or 2
                setOpAddress(operandAddr, Main.getGPR(gpr)); //Set address var 1 or 2 to the contents of said GPR

                if (Main.isValidProgramArea(getOpAddress(operandAddr))) {
                    
                    setOpValue(operandValue, Main.getHypoMemory(getOpAddress(operandAddr)));

                } else {
                    this.error = SystemConstants.ERROR_INVALID_ADDRESS;
                    System.out.printf("%n$ ERROR %d INVALID ADDRESS: GPR %d is invalid in case 4.%n", error, operandAddr);
                }
                break;


            // LINE MODES 5-6: these modes deal with the following line
            //
            // 5: The next line contains a memory location. Retrieve your value from there
            //      - Read and write to that location when performing math operations or moves (op1)
            //
            // 6: The next line contains the value you want to use. Retrieve it directly from there
            //      - Cannot write to the next line when performing math operations or moves (op1)

            //Direct mode: this mode looks at the next line. It assumes whatever value contained in the memory address
            // in the next line is another memory address. Then, it will go to that location and retrieve whatever
            // value is there.
            // This mode will lock you into writing to the same memory location for the current cycle (op1).
            // Use it when you want to fetch from a remote memory location anywhere 

            case 5: //direct mode - "Op address is in the instruction that is in the program counter"
                //Do need to check if PC value is valid because validation is already performed when updating the PC value
                
                //In this case, the PC points to a memory location
                //Retrieve the contents of that memory location
                //Put it inside op address 1 or 2
                setOpAddress(operandAddr, Main.getHypoMemory(Main.getPC()));
                Main.incrementPC(); // -> make sure the PC is moved forward since it should always point to the next place

                //When in fetch mode 5, the assumption is that the
                //location specified by the PC contains another memory location... 
                if (Main.isValidProgramArea(getOpAddress(operandAddr))) {

                    //Go to the memory address in the PC (AKA the next line)
                    //Get whatever is stored there and set it as value either 1 or 2
                    setOpValue(operandValue, Main.getHypoMemory(getOpAddress(operandAddr)));
                } else {
                    this.error = SystemConstants.ERROR_INVALID_ADDRESS;
                    System.out.printf("%n$ ERROR %d INVALID ADDRESS: Op address %d contains %d in case 5.%n", error, operandAddr, getOpAddress(operandAddr));
                }
                break;

            
            //Immediate mode: this mode looks at the next line. It assumes whatever value contained in the memory address
            // in the next line is the value you want to use.
            // Use it when you want to fetch a value directly from the next line
            // This mode locks you from writing (op1) because the CPU will not allow writing in immediate mode. 

            case 6: //immediate mode - "Op value is in the instruction"
                //Do need to check if PC value is valid because validation is already performed when updating the PC value
                setOpAddress(operandAddr, -300);

                //In this case, the program counter contains a memory location
                //Go to that memory location and retrieve the contents of what is stored there
                //Place it inside op value 1 or 2

                //When using mode 6, the assumption is that the
                //location specified by the PC contains a value
                //This is why we do not need to check if that number is
                //in the valid program area, as it is a number and not an address
                setOpValue(operandValue, Main.getHypoMemory(Main.getPC()));
                Main.incrementPC();
                break;

            default: //invalid mode
                this.error = SystemConstants.ERROR_INVALID_FETCH_MODE;
                System.out.printf("%n$ ERROR %d INVALID FETCH MODE: Fetch mode %d does not exist.%n", error, mode);
                break;
        }

        return this.error;
    }


    //************************************************************
    // ACCESSOR METHODS
    //
    // Task Description:
    //    Allows for retrieving values of private variables with
    //    built-in validation
    //
    // Input Parameters
    //    getOpAddress() - int operandAddr
    //    getOpValue()   - int operandValue
    //
    // Output Parameters
    //    None          
    //
    // Function Return Value
    //    getOpAddress() - op1 or op2 address instance variable
    //    getOpValue()   - op1 or op2 value instance variable   
    //    -9000          - impossible address which cycle() method will catch and report error            
    //************************************************************
    public long getOpAddress(int operandAddr) {
        if (operandAddr == 1) {
            return this.op1Address;
        } else if (operandAddr == 2) {
            return this.op2Address; 
        } else {
            return -9000;
        }
    }

    public long getOpValue(int operandValue) {
        if (operandValue == 1) {
            return this.op1Value;
        } else if (operandValue == 2) {
            return this.op2Value;
        } else {
            return -9000;
        }
    }

    public long getCycles() {
        return this.cycles;
    }

    public boolean getHaltStatus() {
        return this.halt;
    }

    public long getErrorStatus() {
        return this.error;
    }


    //************************************************************
    // MUTATOR METHODS
    //
    // Task Description:
    //    Allows for setting values of private variables
    //
    // Input Parameters
    //    setOpAddress() - int operandAddr, long value
    //    setOpValue()   - int operandValue, long value
    //
    // Output Parameters
    //    None          
    //
    // Function Return Value
    //    all             - void              
    //************************************************************
    public void setOpAddress(int operandAddr, long value) {
        if (operandAddr == 1) {
            this.op1Address = value; 
        } else if (operandAddr == 2) {
            this.op2Address = value; 
        }
    }

    public void setOpValue(int operandValue, long value) {
        if (operandValue == 1) {
            this.op1Value = value;
        } else if (operandValue == 2) {
            this.op2Value = value;
        }
    }


    //************************************************************
    // BOOLEAN METHODS
    //
    // Task Description:
    //    Checks if a given GPR is within 0-7
    //
    // Input Parameters
    //    long gpr
    //
    // Output Parameters
    //    None          
    //
    // Function Return Value
    //    true
    //    false             
    //************************************************************
    public boolean isValidGPR(long gpr) {
        return gpr > -1 && gpr < 8;
    }

}



//************************************************************
//
// CLASS: SystemCall
//
// Task performed
//    Has all new external methods not part of the CPU directly
//    and all methods related to system calls and interrupt handling
//
// Input Parameters
//    None
//
// Output Parameters
//    None
//
// Function Return Value
//    None
//
//************************************************************
class SystemCall {

    static Scanner input = new Scanner(System.in);



    // [ MEMORY MANAGEMENT ] //

    //************************************************************
    // Function: MemAlloc
    //
    // Task Description:
    //    System call method to allocate dynamic/heap memory and set new block pointer to GPR1
    //    Allocate memory from user free list
    //    Return status from the function is either the address of allocated memory or an error code
    //
    // Input Parameters
    //    none
    //
    // Output Parameters
    //    long GPR0
    //
    // Function Return Value
    //    OK                                Normal
    //    ERROR_INVALID_MEMORY_SIZE         Invalid memory block size requested
    //    ERROR_NO_FREE_MEMORY              No free block available in the UFL
    //    ERROR_INVALID_ADDRESS             Invalid size/memory block outside user memory range when attempting to free user memory
    //    -                                 Pointer outside of user memory range when attempting to free user memory
    //************************************************************   
    public static long MemAlloc() {

        long size = Main.getGPR(2);
        
        // Add code here to check for size out of range
        if (size > SystemConstants.FREE_LIST_USER_SIZE || size < 1) {
            System.out.printf("%n$ ERROR %d: invalid memory block size requested.%n", SystemConstants.ERROR_INVALID_MEMORY_SIZE);
            return SystemConstants.ERROR_INVALID_MEMORY_SIZE;
        }

        if (size == 1) {
            size = 2;
        }

        //Set GPR1 = AllocateUserMemory passing size as argument
        long blockPointer = allocateUserMemory(size);
        Main.setGPR(1, blockPointer);

        //If GPR1 is less than 0, then there is an error
        //Set that GPR0 to error
        if (Main.getGPR(1) < 0) {
            Main.setGPR(0, Main.getGPR(1));
        } else {

            //Set status in GPR0 to OK if GPR1 contains an address
            Main.setGPR(0, SystemConstants.OK);
        }

        System.out.printf("%n$ System Call ID 4: Mem_alloc\tGPR0: %d\tGPR1: %d\tGPR2: %d\tPID: %d.%n", Main.getGPR(0), Main.getGPR(1), Main.getGPR(2), Main.getHypoMemory(Main.runningPCBPointer + SystemConstants.PCB_PID));

        return Main.getGPR(0);
    }

    //************************************************************
    // Function: MemFree
    //
    // Task Description:
    //    System call method to free dynamic/heap memory
    //    Return dynamically allocated memory to the user free list
    //    GPR1 has memory address and GPR2 has memory size to be released
    //    Return status in GPR0
    //
    // Input Parameters
    //    long GPR1, GPR2
    //
    // Output Parameters
    //    long GPR0
    //
    // Function Return Value
    //    OK                                Normal
    //    ERROR_INVALID_MEMORY_SIZE         Invalid memory block size requested
    //    ERROR_NO_FREE_MEMORY              No free block available in the UFL
    //    ERROR_INVALID_ADDRESS             Invalid size/memory block outside user memory range when attempting to free user memory
    //    -                                 Pointer outside of user memory range when attempting to free user memory
    //************************************************************   
    public static long MemFree() {

        //Declare long Size setting it to GPR2 value;
        long size = Main.getGPR(2);

        //Add code to check for size out of range
        if (size > SystemConstants.FREE_LIST_USER_SIZE || size < 1) {
            System.out.printf("%n$ ERROR %d: invalid memory block size to free.%n", SystemConstants.ERROR_INVALID_MEMORY_SIZE);
            return SystemConstants.ERROR_INVALID_MEMORY_SIZE;
        }

        //Check size of 1 and change it to 2
        if (size == 1) {
            size = 2;
        }

        //Set GPR0 = Call FreeUserMemory(pass GPR1 and Size as arguments);
        long status = freeUserMemory(Main.getGPR(1), size);
        Main.setGPR(0, status);

        //Display Mem_free system call, and parameters GPR0, GPR1, GPR2;
        System.out.printf("%n$ System Call ID 5: Mem_free\tGPR0: %d\tGPR1: %d\tGPR2: %d\tPID: %d.%n", Main.getGPR(0), Main.getGPR(1), Main.getGPR(2), Main.getHypoMemory(Main.runningPCBPointer + SystemConstants.PCB_PID));

        return Main.getGPR(0);
    }

    //************************************************************
    // Function: allocateOSMemory
    //
    // Task Description:
    //    Method that physically assigns new memory from OS free list
    //    Returns pointer to dynamically allocated memory from the OS free list
    //
    // Input Parameters
    //    long requestedSize
    //
    // Output Parameters
    //    long error, currentPointer
    //
    // Function Return Value
    //    OK                                Normal
    //    ERROR_INVALID_MEMORY_SIZE         Invalid memory block size requested
    //    ERROR_NO_FREE_MEMORY              No free block available in the UFL
    //    ERROR_INVALID_ADDRESS             Invalid size/memory block outside user memory range when attempting to free user memory
    //    -                                 Pointer outside of user memory range when attempting to free user memory
    //    currentPointer                    Assigned block pointer
    //************************************************************   
    //long AllocateOSMemory (long RequestedSize);
    public static long allocateOSMemory(long requestedSize) {

        long error = SystemConstants.OK;

        if (Main.getOSFreeList() == SystemConstants.END_OF_LIST) {
            error = SystemConstants.ERROR_NO_FREE_MEMORY;
            System.out.printf("%n$ ERROR %d: no free block available in the OS free list (OFL).%n", error);
            return error; 
        }
        
        if (requestedSize < 0) {
            error = SystemConstants.ERROR_INVALID_MEMORY_SIZE;
            System.out.printf("%n$ ERROR %d: invalid memory block size requested.%n", error);
            return error; 
        }

        if (requestedSize == 1) {
            requestedSize = 2;
        }

        long currentPointer = Main.getOSFreeList(); //SystemConstants.FREE_LIST_OS;
        long previousPointer = SystemConstants.END_OF_LIST;

        while (currentPointer != SystemConstants.END_OF_LIST) {

            //If the value stored inside the current pointer+1 (initially set to start of the address space)
            //matches the requested size, then proceed
            if (Main.getHypoMemory(currentPointer+1) == requestedSize) {
                
                //If the current pointer (initially set to start of the address space)
                //is the same as the address contained in the osFreeList var in Main, then proceed
                if (currentPointer == Main.getOSFreeList()) {

                    //Set the osFreeList var to the whatever is inside that memory address
                    //specified by currentPointer
                    Main.setOSFreeList(Main.getHypoMemory(currentPointer));

                    //Set the currentPointer to the END_OF_LIST value (-9999) to break the loop
                    Main.setHypoMemory(currentPointer, SystemConstants.END_OF_LIST);
                    return currentPointer;
                } else {

                    //Set the value of the first address in the previous memory block
                    //to whatever is stored in the first address of the current memory block
                    Main.setHypoMemory(previousPointer, Main.getHypoMemory(currentPointer));

                    //Set the currentPointer to the END_OF_LIST value (-9999) to break the loop
                    Main.setHypoMemory(currentPointer, SystemConstants.END_OF_LIST);
                    return currentPointer;
                } 
            

            //If the value stored inside the current pointer+1 (initially set to start of the address space)
            //is greater than the requested size, then proceed
            } else if (Main.getHypoMemory(currentPointer+1) > requestedSize) {
                
                //If the current pointer (initially set to start of the address space)
                //is the same as the address contained in the osFreeList var in Main, then proceed
                if (currentPointer == Main.getOSFreeList()) {

                    //Go to the last memory location in the requested block and set its contents to
                    //whatever is inside the memory location specified by the current pointer
                    //(initially set to start of the address space)
                    //Thus, move the next free block pointer to the end of that used block (indicating a new free block)
                    /*a*/ Main.setHypoMemory(currentPointer + requestedSize, Main.getHypoMemory(currentPointer));

                    //Go to the memory location directly after the requested block and set its contents to
                    //whatever is inside the memory location specified by the current pointer+1
                    //Then, subtract that quantity by the requested size
                    //Thus, move the next free block size to the location after the next free block pointer
                    //This indicates the size of the next free block
                    /*b*/ Main.setHypoMemory(currentPointer + requestedSize + 1, Main.getHypoMemory(currentPointer+1) - requestedSize);
                    
                    //Set the osFreeList var in Main to the address calculated by part /*a*/
                    //Thus, set the osFreeList pointer to point to the first address of the new reduced block
                    /*c*/ Main.setOSFreeList(currentPointer + requestedSize);

                    //Go to the memory location specified by the current pointer and set its contents
                    //to be the END_OF_LIST constant (-9999)
                    //Thus, make that block not point to the next free block
                    //Make it point to nothing because it is no longer a free block
                    //It is a block that is being used
                    /*d*/ Main.setHypoMemory(currentPointer, SystemConstants.END_OF_LIST); // reset next pointer in the allocated block
                    
                    return currentPointer; // return memory address of the block ready to be used
                } else {
                    Main.setHypoMemory(currentPointer + requestedSize, Main.getHypoMemory(currentPointer)); // move next block ptr
                    Main.setHypoMemory(currentPointer + requestedSize + 1, Main.getHypoMemory(currentPointer+1) - requestedSize);
                    
                    if (previousPointer != SystemConstants.END_OF_LIST) {
                        Main.setHypoMemory(previousPointer, currentPointer + requestedSize); // address of reduced block
                    }
                    
                    //Set the currentPointer to the END_OF_LIST value (-9999) to break the loop
                    Main.setHypoMemory(currentPointer, SystemConstants.END_OF_LIST);
                    return currentPointer; // return memory address
                }

            } else { //Small block

                //If the block is too small, change previous pointer pointer (initially set to EOL)
                //to the current pointer (initially set to beginning of OS memory space)
                previousPointer = currentPointer;

                //Go to the current pointer in memory and retrieve whatever is stored there
                //It should point to the next free block
                currentPointer = Main.getHypoMemory(currentPointer);
            }
        }

        error = SystemConstants.ERROR_NO_FREE_MEMORY;
        System.out.printf("%n$ ERROR %d: No free OS memory.%n", error);
        return error;
    }

    //************************************************************
    // Function: allocateUserMemory
    //
    // Task Description:
    //    Method that physically assigns new memory from user free list
    //    Returns pointer to dynamically allocated memory from the user free list
    //
    // Input Parameters
    //    long requestedSize
    //
    // Output Parameters
    //    long error, currentPointer
    //
    // Function Return Value
    //    OK                                Normal
    //    ERROR_INVALID_MEMORY_SIZE         Invalid memory block size requested
    //    ERROR_NO_FREE_MEMORY              No free block available in the UFL
    //    ERROR_INVALID_ADDRESS             Invalid size/memory block outside user memory range when attempting to free user memory
    //    -                                 Pointer outside of user memory range when attempting to free user memory
    //    currentPointer                    Assigned block pointer
    //************************************************************ 
    //Long AllocateUserMemory (long size);
    public static long allocateUserMemory(long requestedSize) {

        long error = SystemConstants.OK;

        if (Main.getUserFreeList() == SystemConstants.END_OF_LIST) {
            error = SystemConstants.ERROR_NO_FREE_MEMORY;
            System.out.printf("%n$ ERROR %d: no free block available in the user free list (UFL).%n", error);
            return error; 
        }
        
        if (requestedSize < 0) {
            error = SystemConstants.ERROR_INVALID_MEMORY_SIZE;
            System.out.printf("%n$ ERROR %d: invalid memory block size requested.%n", error);
            return error; 
        }

        if (requestedSize == 1) {
            requestedSize = 2;
        }

        long currentPointer = Main.getUserFreeList();
        long previousPointer = SystemConstants.END_OF_LIST;

        while (currentPointer != SystemConstants.END_OF_LIST) {

            //If the value stored inside the current pointer+1 (initially set to start of the address space)
            //matches the requested size, then proceed
            if (Main.getHypoMemory(currentPointer+1) == requestedSize) {
                
                //If the current pointer (initially set to start of the address space)
                //is the same as the address contained in the osFreeList var in Main, then proceed
                if (currentPointer == Main.getUserFreeList()) {

                    //Set the userFreeList var to the whatever is inside that memory address
                    //specified by currentPointer
                    Main.setUserFreeList(Main.getHypoMemory(currentPointer));

                    //Set the currentPointer to the END_OF_LIST value (-9999) to break the loop
                    Main.setHypoMemory(currentPointer, SystemConstants.END_OF_LIST);
                    return currentPointer;

                } else {

                    //Set the value of the first address in the previous memory block
                    //to whatever is stored in the first address of the current memory block
                    Main.setHypoMemory(previousPointer, Main.getHypoMemory(currentPointer));
                    //System.out.printf("%nim here 2%n");
                    //Set the currentPointer to the END_OF_LIST value (-9999) to break the loop
                    Main.setHypoMemory(currentPointer, SystemConstants.END_OF_LIST);
                    return currentPointer;
                } 
            

            //If the value stored inside the current pointer+1 (initially set to start of the address space)
            //is greater than the requested size, then proceed
            } else if (Main.getHypoMemory(currentPointer+1) > requestedSize) {
                
                //If the current pointer (initially set to start of the address space)
                //is the same as the address contained in the userFreeList var in Main, then proceed
                if (currentPointer == Main.getUserFreeList()) {

                    //Go to the last memory location in the requested block and set its contents to
                    //whatever is inside the memory location specified by the current pointer
                    //(initially set to start of the address space)
                    //Thus, move the next free block pointer to the end of that used block (indicating a new free block)
                    /*a*/ Main.setHypoMemory(currentPointer + requestedSize, Main.getHypoMemory(currentPointer));

                    //Go to the memory location directly after the requested block and set its contents to
                    //whatever is inside the memory location specified by the current pointer+1
                    //Then, subtract that quantity by the requested size
                    //Thus, move the next free block size to the location after the next free block pointer
                    //This indicates the size of the next free block
                    /*b*/ Main.setHypoMemory(currentPointer + requestedSize + 1, Main.getHypoMemory(currentPointer+1) - requestedSize);
                    
                    //Set the userFreeList var in Main to the address calculated by part /*a*/
                    //Thus, set the userFreeList pointer to point to the first address of the new reduced block
                    /*c*/ Main.setUserFreeList(currentPointer + requestedSize);
                    
                    //Go to the memory location specified by the current pointer and set its contents
                    //to be the END_OF_LIST constant (-9999)
                    //Thus, make that block not point to the next free block
                    //Make it point to nothing because it is no longer a free block
                    //It is a block that is being used
                    /*d*/ Main.setHypoMemory(currentPointer, SystemConstants.END_OF_LIST); // reset next pointer in the allocated block
                    
                    return currentPointer; // return memory address of the block ready to be used
                } else {
                    Main.setHypoMemory(currentPointer + requestedSize, Main.getHypoMemory(currentPointer)); // move next block ptr
                    Main.setHypoMemory(currentPointer + requestedSize + 1, Main.getHypoMemory(currentPointer+1) - requestedSize);
                    //System.out.printf("%nim here 3; UFL PTR=%d%n", Main.getUserFreeList());
                    
                    if (previousPointer != SystemConstants.END_OF_LIST) {
                        Main.setHypoMemory(previousPointer, currentPointer + requestedSize); // address of reduced block
                    }
                    
                    //Set the currentPointer to the END_OF_LIST value (-9999) to break the loop
                    Main.setHypoMemory(currentPointer, SystemConstants.END_OF_LIST);

                    //Returns pointer to block which is occupied by the stack
                    return currentPointer; // return memory address
                }

            } else { //Small block

                //If the block is too small, change previous pointer pointer (initially set to EOL)
                //to the current pointer (initially set to beginning of OS memory space)
                previousPointer = currentPointer;

                //Go to the current pointer in memory and retrieve whatever is stored there
                //It should point to the next free block
                currentPointer = Main.getHypoMemory(currentPointer);
            }
        }

        error = SystemConstants.ERROR_NO_FREE_MEMORY;
        System.out.printf("%n$ ERROR %d: No free user memory.%n", error);
        return error;
    }

    //************************************************************
    // Function: freeOSMemory
    //
    // Task Description:
    //    Method that physically frees dynamic memory and releases to the OS free list
    //
    // Input Parameters
    //    long pointer, size
    //
    // Output Parameters
    //    long error
    //
    // Function Return Value
    //    OK                                Normal
    //    ERROR_INVALID_ADDRESS             Invalid size/memory block outside user memory range when attempting to free user memory
    //    -                                 Pointer outside of user memory range when attempting to free user memory
    //************************************************************ 
    //long freeOSMemory (long ptr,  long size);
    public static long freeOSMemory(long pointer, long size) {
        
        long error = SystemConstants.OK;

        if (!(Main.isOSMemory(pointer))) {       
            error = SystemConstants.ERROR_INVALID_ADDRESS;
            System.out.printf("%n$ ERROR %d: pointer outside of OS memory range when attempting to free OS memory.%n", error);
            return error;   
        }

        if (size == 1) {
            size = 2;
        } else if (size < 1 || pointer + size >= SystemConstants.FREE_LIST_OS + SystemConstants.FREE_LIST_OS_SIZE) {
            error = SystemConstants.ERROR_INVALID_ADDRESS;
            System.out.printf("%n$ ERROR %d: invalid size/memory block outside OS memory range when attempting to free OS memory.%n", error);
            return error;
        }

        // Return memory to OS free space.  Insert at the beginning of the linked list
        //Insert the given free block at the beginning of the OS free list

        //Make the given free block point to free block pointed by OS free List
        Main.setHypoMemory(pointer, Main.getOSFreeList());

        //Set the free block size in the given free block
        Main.setHypoMemory(pointer+1, size);

        //Set OS Free List point to the given free block
        Main.setOSFreeList(pointer);

        return error;
    }

    //************************************************************
    // Function: freeUserMemory
    //
    // Task Description:
    //    Method that physically frees dynamic memory and releases to the user free list
    //
    // Input Parameters
    //    long pointer, size
    //
    // Output Parameters
    //    long error
    //
    // Function Return Value
    //    OK                                Normal
    //    ERROR_INVALID_ADDRESS             Invalid size/memory block outside user memory range when attempting to free user memory
    //    -                                 Pointer outside of user memory range when attempting to free user memory
    //************************************************************ 
    //long freeUserMemory (long ptr,  long size);
    public static long freeUserMemory(long pointer, long size) {
        
        long error = SystemConstants.OK;

        if (!(Main.isUserMemory(pointer))) {       
            error = SystemConstants.ERROR_INVALID_ADDRESS;
            System.out.printf("%n$ ERROR %d: pointer outside of user memory range when attempting to free user memory.%n", error);
            return error;   
        }

        if (size == 1) {
            size = 2;
        } else if (size < 1 || pointer + size >= SystemConstants.FREE_LIST_USER + SystemConstants.FREE_LIST_USER_SIZE) {
            error = SystemConstants.ERROR_INVALID_ADDRESS;
            System.out.printf("%n$ ERROR %d: invalid size/memory block outside user memory range when attempting to free user memory.%n", error);
            return error;
        }

        //Return memory to user free space.  Insert at the beginning of the linked list
        //Insert the given free block at the beginning of the user free list

        //Make the given free block point to free block pointed by user free List
        Main.setHypoMemory(pointer, Main.getUserFreeList());

        //Set the free block size in the given free block
        Main.setHypoMemory(pointer+1, size);

        //Set user Free List pointer to the given free block
        Main.setUserFreeList(pointer);

        return error;
    }



    // [ PROCESS MANAGEMENT ] //

    //************************************************************
    // Function: initializePCB
    //
    // Task Description:
    //    Accepts pointer to a newly created PCB in OS free space and sets up default values
    //    based on PCB offsets defined in SystemConstants
    //
    // Input Parameters
    //    long pcbPointer
    //
    // Output Parameters
    //    none
    //
    // Function Return Value
    //    none
    //************************************************************ 
    //void InitializePCB (long PCBptr)
    public static void initializePCB(long pcbPointer) {

        // Set entire PCB area to 0 using PCBptr;    // Array initialization
        for (int i = 0; i < SystemConstants.PCB_LEN; i++) {
            Main.setHypoMemory(pcbPointer + i, 0);
        }

        // Allocate PID and set it in the PCB. PID zero is invalid
        ////Set PID field in the PCB to = ProcessID++;  // ProcessID is global variable initialized to 1
        Main.setHypoMemory(pcbPointer + SystemConstants.PCB_PID, Main.processID++);

        //Set priority field in the PCB = Default Priority;  // DefaultPriority is a constant set to 128
        Main.setHypoMemory(pcbPointer + SystemConstants.PCB_PRIORITY, SystemConstants.DEFAULT_PRIORITY);

        //Set state field in the PCB = ReadyState;    // ReadyState is a constant set to 1
        Main.setHypoMemory(pcbPointer + SystemConstants.PCB_STATE, SystemConstants.PROC_READY);

        //Set next PCB pointer field in the PCB = EndOfList;  // EndOfList is a constant set to -1
        Main.setHypoMemory(pcbPointer + SystemConstants.PCB_NEXT, SystemConstants.END_OF_LIST);
    }

    //************************************************************
    // Function: printPCB
    //
    // Task Description:
    //    Prints process details from PCB stored in OS dynamic memory
    //    based on PCB offsets defined in SystemConstants
    //
    // Input Parameters
    //    long pcbPointer
    //
    // Output Parameters
    //    none
    //
    // Function Return Value
    //    none
    //************************************************************
    //Void PrintPCB(long PCBptr)
    public static void printPCB(long pcbPointer) {
        System.out.printf("%nPCB address = %d, Next PCB ptr = %d, PID = %d, State = %d, PC = %d, SP = %d,", pcbPointer, Main.getHypoMemory(pcbPointer + SystemConstants.PCB_NEXT), Main.getHypoMemory(pcbPointer + SystemConstants.PCB_PID), Main.getHypoMemory(pcbPointer + SystemConstants.PCB_STATE), Main.getHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_PC), Main.getHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_SP));
        System.out.printf("%nPriority = %d, Stack info: start address = %d, size = %d", Main.getHypoMemory(pcbPointer + SystemConstants.PCB_PRIORITY), Main.getHypoMemory(pcbPointer + SystemConstants.PCB_STACK_START), Main.getHypoMemory(pcbPointer + SystemConstants.PCB_STACK_SIZE));
        System.out.printf("%nGPRs = %d %d %d %d %d %d %d %d%n", Main.getHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_GPR0), Main.getHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_GPR1), Main.getHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_GPR2), Main.getHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_GPR3), Main.getHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_GPR4), Main.getHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_GPR5), Main.getHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_GPR6), Main.getHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_GPR7));
    }

    //************************************************************
    // Function: printQueue
    //
    // Task Description:
    //    Walk through the queue from the given pointer until end of list
    //    Print each PCB as you move from one PCB to the next
    //
    // Input Parameters
    //    long queuePointer
    //
    // Output Parameters
    //    none
    //
    // Function Return Value
    //    OK                        Normal
    //************************************************************
    //long PrintQueue (long Qptr)
    public static long printQueue(long queuePointer) {
        // Walk thru the queue from the given pointer until end of list
        // Print each PCB as you move from one PCB to the next

        // Declare long currentPCBPtr = Qptr;
        long currentPCBPointer = queuePointer;

        if (currentPCBPointer == SystemConstants.END_OF_LIST) {
            System.out.printf("%nCurrent list is empty!%n");
            return SystemConstants.OK;
        }

        // Walk thru the queue
        while (currentPCBPointer != SystemConstants.END_OF_LIST) {
            printPCB(currentPCBPointer);
            currentPCBPointer = Main.getHypoMemory(currentPCBPointer + SystemConstants.PCB_NEXT);
        }

        return SystemConstants.OK;
    }

    //************************************************************
    // Function: insertIntoRQ
    //
    // Task Description:
    //    Insert PCB according to Priority Round Robin algorithm into ready queue
    //    Use priority in the PCB to find the correct place to insert.
    //
    // Input Parameters
    //    long pcbPointer
    //
    // Output Parameters
    //    none
    //
    // Function Return Value
    //    OK                            Normal
    //    ERROR_INVALID_ADDRESS         Invalid PCB address given
    //************************************************************
    // long InsertIntoRQ (long pcbPointer)
    public static long insertIntoRQ(long pcbPointer) {

        long error = SystemConstants.OK;

        // Insert PCB according to Priority Round Robin algorithm
        // Use priority in the PCB to find the correct place to insert.
        long previousPointer = SystemConstants.END_OF_LIST;
        long currentPointer = Main.getRQ();

        // Check for invalid PCB memory address
        if (pcbPointer < 0 || pcbPointer > SystemConstants.WORDSIZE) {
            error = SystemConstants.ERROR_INVALID_ADDRESS;
            System.out.printf("%n$ ERROR %d: invalid PCB address.%n", error);
            return error;
        }

        Main.setHypoMemory(pcbPointer + SystemConstants.PCB_STATE, SystemConstants.PROC_READY); // set state to ready state
        Main.setHypoMemory(pcbPointer + SystemConstants.PCB_NEXT, SystemConstants.END_OF_LIST); // set next pointer to end of list

        // RQ is empty
        if (Main.getRQ() == SystemConstants.END_OF_LIST) {
            Main.setRQ(pcbPointer);
            return error;
        }

        // Walk thru RQ and find the place to insert
        // PCB will be inserted at the end of its priority

        while ( currentPointer != SystemConstants.END_OF_LIST) {

            if (Main.getHypoMemory(pcbPointer + SystemConstants.PCB_PRIORITY) > Main.getHypoMemory(currentPointer + SystemConstants.PCB_PRIORITY)) {

                // found the place to insert
                if (previousPointer == SystemConstants.END_OF_LIST) {

                    // Enter PCB in the front of the list as first entry
                    Main.setHypoMemory(pcbPointer + SystemConstants.PCB_NEXT, Main.getRQ());
                    Main.setRQ(pcbPointer);
                    return error;
                }

                // enter PCB in the middle of the list
                Main.setHypoMemory(pcbPointer + SystemConstants.PCB_NEXT, Main.getHypoMemory(previousPointer + SystemConstants.PCB_NEXT));
                Main.setHypoMemory(previousPointer + SystemConstants.PCB_NEXT, pcbPointer);
                return error;

            } else { // PCB to be inserted has lower or equal priority to the current PCB in RQ
                // go to the next PCB in RQ
                previousPointer = currentPointer;
                currentPointer = Main.getHypoMemory(currentPointer + SystemConstants.PCB_NEXT);
            }
        }

        // Insert PCB at the end of the RQ
        Main.setHypoMemory(previousPointer + SystemConstants.PCB_NEXT, pcbPointer);
        
        return error;    
    }

    //************************************************************
    // Function: insertIntoWQ
    //
    // Task Description:
    //    Insert the given PCB at the front of the OS waiting queue
    //
    // Input Parameters
    //    long pcbPointer
    //
    // Output Parameters
    //    none
    //
    // Function Return Value
    //    OK                            Normal
    //    ERROR_INVALID_ADDRESS         Invalid PCB address given
    //************************************************************
    //long InsertIntoWQ (long pcbPointer)
    public static long insertIntoWQ(long pcbPointer) {
        // Insert the given PCB at the front of WQ

        long error = SystemConstants.OK;

        // Check for invalid PCB memory address
        if (pcbPointer < 0 || pcbPointer > SystemConstants.WORDSIZE) {
            error = SystemConstants.ERROR_INVALID_ADDRESS;
            System.out.printf("%n$ ERROR %d: invalid PCB address.%n", error);
            return error;
        }

        // set state to ready state
        Main.setHypoMemory(pcbPointer + SystemConstants.PCB_STATE, SystemConstants.PROC_WAIT);

        // set next pointer to end of list
        Main.setHypoMemory(pcbPointer + SystemConstants.PCB_NEXT, Main.getWQ());

        Main.setWQ(pcbPointer);

        return error;
    }

    //************************************************************
    // Function: selectProcessFromRQ
    //
    // Task Description:
    //    Get the first PCB in the ready queue and return a pointer to it
    //    Also make sure the RQ is no longer pointing to the chosen PCB
    //
    // Input Parameters
    //    none
    //
    // Output Parameters
    //    none
    //
    // Function Return Value
    //    pcbPointer                    THE first PCB in the RQ or EOL
    //************************************************************
    //long SelectProcessFromRQ()
    public static long selectProcessFromRQ() {

        // first entry in RQ
        long pcbPointer = Main.getRQ();

        if (Main.getRQ() != SystemConstants.END_OF_LIST) {
            // Remove first PCB from RQ
            Main.setRQ(Main.getHypoMemory(Main.getRQ() + SystemConstants.PCB_NEXT));
        }

        if (pcbPointer != SystemConstants.END_OF_LIST) {
            // Set next point to EOL in the PCB only if PCB pointer exists
            Main.setHypoMemory(pcbPointer + SystemConstants.PCB_NEXT, SystemConstants.END_OF_LIST);
        }

        return pcbPointer;
    }

    //************************************************************
    // Function: searchAndRemovePCBFromWQ
    //
    // Task Description:
    //    Search WQ for a PCB that has the given pid
    //    If a match is found, remove it from WQ and return the PCB pointer
    //    If no matching PCB is found, display a message and return EOL
    //
    // Input Parameters
    //    long pid
    //
    // Output Parameters
    //    none
    //
    // Function Return Value
    //    currentPCBPointer              The found PCB pointer
    //    END_OF_LIST                    PID not found in Waiting Queue
    //************************************************************
    //long SearchAndRemovePCBfromWQ ( long pid)
    public static long searchAndRemovePCBFromWQ(long pid) {
        
        long currentPCBPointer = Main.getWQ();
        long previousPCBPointer = SystemConstants.END_OF_LIST;

        // Search WQ for a PCB that has the given pid
        // If a match is found, remove it from WQ and return the PCB pointer
        while (currentPCBPointer != SystemConstants.END_OF_LIST) {

            //If(Memory[PCBptr + pidIndex] == pid)
            if (Main.getHypoMemory(currentPCBPointer + SystemConstants.PCB_PID) == pid) {

                // match found, remove from WQ
                if(previousPCBPointer == SystemConstants.END_OF_LIST) {
                    // first PCB
                    //WQ = Memory[currentPCBptr + nextPCBIndex];
                    Main.setWQ(Main.getHypoMemory(currentPCBPointer + SystemConstants.PCB_NEXT));
                } else {   
                    //not first PCB
                    //Sets the next PCB pointer of the previous PCB to the NEXT pointer stored in the current PCB
                    Main.setHypoMemory(previousPCBPointer + SystemConstants.PCB_NEXT, Main.getHypoMemory(currentPCBPointer + SystemConstants.PCB_NEXT));
                }

                //Memory[currentPCBptr+nextPCBIndex] = EndOfList;
                Main.setHypoMemory(currentPCBPointer + SystemConstants.PCB_NEXT, SystemConstants.END_OF_LIST);

                return currentPCBPointer;
            }

            //previousPCBptr = currentPCBptr;
            previousPCBPointer = currentPCBPointer;

            //currentPCBptr = Memory[currentPCBptr + nextPCBIndex];
            currentPCBPointer = Main.getHypoMemory(currentPCBPointer + SystemConstants.PCB_NEXT);
        }

        // No matching PCB is found, display pid message and return End of List code
        //Display pid not found message;
        System.out.printf("%n$ ERROR %d: PID %d not found in Waiting Queue.%n", SystemConstants.ERROR, pid);

        return SystemConstants.END_OF_LIST;
    }

    //************************************************************
    // Function: saveContext
    //
    // Task Description:
    //    Given a PCB pointer, save the CPU context into the correct locations
    //    using PCB offsets defined in SystemConstants
    //    This includes all GPRs, SP, and PC
    //
    // Input Parameters
    //    long pcbPointer
    //
    // Output Parameters
    //    none
    //
    // Function Return Value
    //    none
    //************************************************************
    //void SaveContext(long PCBptr)
    public static void saveContext(long pcbPointer) {
        // Assume PCBptr is a valid pointer.

        //Copy all CPU GPRs into PCB using PCBptr with or without using loop
        for (int i = 0; i < 8; i++) {
            Main.setHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_GPR0 + i, Main.getGPR(i));
        }

        //Set SP field in the PCB = SP;    // Save SP
        Main.setHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_SP, Main.getSP());

        //Set PC field in the PCB = PC;    // Save PC
        Main.setHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_PC, Main.getPC());
    }

    //************************************************************
    // Function: dispatcher
    //
    // Task Description:
    //    Opposite of save context; load all the CPU context into hardware from PCB
    //    using PCB offsets defined in SystemConstants
    //    This includes all GPRs, SP, and PC - also set PSR to user mode
    //
    // Input Parameters
    //    long pcbPointer
    //
    // Output Parameters
    //    none
    //
    // Function Return Value
    //    none
    //************************************************************
    //void Dispatcher(long PCBptr)
    public static void dispatcher(long pcbPointer) {
        // PCBptr is assumed to be correct.
        // Execute only if pcbPointer != EOL

        if (pcbPointer != SystemConstants.END_OF_LIST) {
            
            // Copy CPU GPR register values from given PCB into the CPU registers
            // This is opposite of save CPU context
            for (int i = 0; i < 8; i++) {
                Main.setGPR(i, Main.getHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_GPR0 + i));
            }

            // Restore SP and PC from given PCB
            Main.setSP(Main.getHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_SP));
            Main.setPC(Main.getHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_PC));

            // Set system mode to User mode
            // PSR = UserMode;    // UserMode is 2, OSMode is 1.
            Main.setPSR(SystemConstants.MODE_USER);

        }

    }

    //************************************************************
    // Function: terminateProcess
    //
    // Task Description:
    //    Given a PCB pointer, return stack memory using stack start address
    //    and stack size in the given PCB and return PCB memory using the pointer
    //
    // Input Parameters
    //    long pcbPointer
    //
    // Output Parameters
    //    none
    //
    // Function Return Value
    //    none
    //************************************************************
    //Void TerminateProcess (long PCBptr)
    public static void terminateProcess(long pcbPointer) {

        // Return stack memory using stack start address and stack size in the given PCB
        long stackStart = Main.getHypoMemory(pcbPointer + SystemConstants.PCB_STACK_START);
        long stackSize = Main.getHypoMemory(pcbPointer + SystemConstants.PCB_STACK_SIZE);
        freeUserMemory(stackStart, stackSize);

        // Return PCB memory using the PCBptr
        freeOSMemory(pcbPointer, SystemConstants.PCB_LEN);
    }

    //************************************************************
    // Function: createProcess
    //
    // Task Description:
    //    Creates PCB using OS dynamic memory, loads program into the program area,
    //    creates process stack using user dynamic memory, and updates PCB values 
    //    to reflect the new stack, and inserts the process PCB into the ready queue
    //    also prints out the program area and new PCB to verify successful creation
    //
    // Input Parameters
    //    String fileName, long priority
    //
    // Output Parameters
    //    none
    //
    // Function Return Value
    //    OK                                Normal
    //    ERROR_INVALID_MEMORY_SIZE         Invalid memory block size requested
    //    ERROR_NO_FREE_MEMORY              No free block available in the UFL
    //    ERROR_INVALID_ADDRESS             Invalid size/memory block outside user memory range when attempting to free user memory
    //    -                                 Pointer outside of user memory range when attempting to free user memory
    //    currentPointer                    Assigned block pointer
    //    pcValue                           Failure loading program into main memory
    //************************************************************
    //long CreateProcess (char &filename, long priority)    // or char * pointer
    public static long createProcess(String fileName, long priority) {

        // Allocate space for Process Control Block
        //Set PCBptr = Allocate OS Memory for PCB;  // return value contains address or error
        long pcbPointer = allocateOSMemory(SystemConstants.PCB_LEN);

        //Check for error and return error code, if memory allocation failed
        if (pcbPointer < 0) {
            System.out.printf("%n$ ERROR %d: PCB allocation failed.%n", pcbPointer);
            return pcbPointer;
        }

        // Initialize PCB: Set nextPCBlink to end of list, default priority, Ready state, and PID
        //Initialize PCB passing PCBptr as argument;
        initializePCB(pcbPointer);

        // Load the program
        //Set value =load the program calling by Absolute Loader passing filename as argument;
        AbsoluteLoader absoluteLoader = new AbsoluteLoader(fileName); //New instance
        long pcValue = absoluteLoader.load();
        
        //Check for error and return error code, if loading program failed
        if (pcValue < 0) {
            System.out.printf("%n$ ERROR %d: failure loading program into main memory.%n", pcValue);
            return pcValue;
        }

        // store PC value in the PCB of the process
        //Set PC value in the PCB = value;  
        Main.setHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_PC, pcValue);

        // Allocate stack space from user free list
        //Set ptr = Allocate User Memory of size StackSize;
        long stackPointer = allocateUserMemory(SystemConstants.STACK_SIZE);

        if (stackPointer < 0) {  // check for error if User memory allocation failed
            
            //Free allocated PCB space by calling Free OS Memory passing PCBptr and  PCBsize;
            freeOSMemory(pcbPointer, SystemConstants.PCB_LEN);
            System.out.printf("%n$ ERROR %d: Failure allocating process stack.%n", stackPointer);
            
            return stackPointer;  // return error code
        }

        // Store stack information in the PCB – SP, ptr, and size
        //Set SP in the PCB = ptr + Stack Size;  // empty stack is high address, full is low address
        Main.setHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_SP, stackPointer);

        //Set stack start address in the PCB to ptr;
        Main.setHypoMemory(pcbPointer + SystemConstants.PCB_STACK_START, stackPointer);

        //Set stack size in the PCB = Stack Size;
        Main.setHypoMemory(pcbPointer + SystemConstants.PCB_STACK_SIZE, SystemConstants.STACK_SIZE);

        //Set priority in the PCB = priority;    // Set priority
        Main.setHypoMemory(pcbPointer + SystemConstants.PCB_PRIORITY, priority);

        //Dump program area;
        //Calculate total program area at the end and change vals
        Main.dumpMemory("Program area after new process creation", 0, 110);

        //Print PCB passing PCBptr; 
        printPCB(pcbPointer);

        // Insert PCB into Ready Queue according to the scheduling algorithm
        // Insert PCB into Ready Queue passing PCBptr;
        insertIntoRQ(pcbPointer);

        return SystemConstants.OK;
    }  // end of CreateProcess() function



    // [ INTERRUPT SERVICING ] //

    //************************************************************
    // Function: checkAndProcessInterrupt
    //
    // Task Description:
    //    Grab an interrupt ID from the user and use a switch statement to execute
    //    the correct interrupt service routine
    //    also prints a menu listing what each ID represents
    //
    // Input Parameters
    //    none
    //
    // Output Parameters
    //    none
    //
    // Function Return Value
    //    interruptID               return the ID that the user entered
    //************************************************************
    //Void CheckAndProcessInterrupt()
    public static long checkAndProcessInterrupt() {
        // Prompt and read interrupt ID

        System.out.printf("%nIssue an interrupt:");
        System.out.printf("%n   0 - No interrupt/continue");
        System.out.printf("%n   1 - Run program");
        System.out.printf("%n   2 - Shutdown system");
        System.out.printf("%n   3 - Input operation completion (io_getc)");
        System.out.printf("%n   4 - Output operation completion (io_putc)%n");
        
        //Read interrupt ID;
        System.out.printf("%n>>> ");
        long interruptID = input.nextLong();

        //Display the interrupt value that was read;
        System.out.printf("%nInterrupt received: %d", interruptID);

        
        // Process interrupt
        switch((int)interruptID) {
            case 0:     // No interrupt
                break;

            case 1:     // Run program
                //call ISR run Program Interrupt function;
                interruptRunProgram();
                break;

            case 2:     // Shutdown system
                //call ISR shutdown System Interrupt function;
                interruptShutdownSystem();
                //set system shutdown status in a global variable to check in main and exit;
                break; 

            case 3:     // Input operation completion – io_getc
                //call ISR input Completion Interrupt function;
                interruptInputCompletion();
                break;

            case 4:     // Output operation completion – io_putc
                //call ISR output Completion Interrupt function;
                interruptOutputCompletion();
                break;

            default:        // Invalid Interrupt ID
                //Display invalid interrupt ID message;
                System.out.printf("%n$ ERROR %d: invalid interrupt ID %d.%n", SystemConstants.ERROR, interruptID);
                break;
        }

        return interruptID;
    }

    //************************************************************
    // Function: interruptRunProgram
    //
    // Task Description:
    //    Gets program path from user and uses it by calling createProcess()
    //    Creates a new process at the default priority (128)
    //    the correct interrupt service routine
    //
    // Input Parameters
    //    none
    //
    // Output Parameters
    //    none
    //
    // Function Return Value
    //    none
    //************************************************************
    //void ISRrunProgramInterrupt();
    public static void interruptRunProgram() {
        //Prompt and read filename
        System.out.printf("%n$ Enter program file name >>> ");
        String fileName = input.nextLine();
        fileName = input.nextLine();

        //Call Create Process passing filename and Default Priority as arguments
        createProcess(fileName, SystemConstants.DEFAULT_PRIORITY);
    }

    //************************************************************
    // Function: interruptInputCompletion
    //
    // Task Description:
    //    Reads PID of the process completing input completion interrupt (io_getc),
    //    searches WQ to find the PCB having the given PID, gets input from the user for 1 character,
    //    THEN stores that character in GPR1 of the process PCB. This is because the process is not
    //    running
    //    Finally, insert the process back into the ready queue to be dispatched and ran
    //
    // Input Parameters
    //    none
    //
    // Output Parameters
    //    ERROR                 PID is invalid
    //
    // Function Return Value
    //    none
    //************************************************************
    //Void ISRinputCompletionInterrupt()
    public static void interruptInputCompletion() {
        //Prompt and read PID of the process completing input completion interrupt;
        System.out.printf("%n$ Enter the PID of the process completing the input completion interrupt >>> ");
        long pid = input.nextLong();

        //Search WQ to find the PCB having the given PID
        long pcbPointer = searchAndRemovePCBFromWQ(pid);
        
        if (pcbPointer > 0) {
            //Read one character from standard input device keyboard;
            System.out.printf("%n$ Enter a character >>> ");
            char character = input.next().charAt(0);
            
            //Store the character in the GPR in the PCB;   // type cast char to long
            //Main.setGPR(1, (long)character);
            Main.setHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_GPR1, (long)character);

            //Set process state to Ready in the PCB;
            Main.setHypoMemory(pcbPointer + SystemConstants.PCB_STATE, SystemConstants.PROC_READY);
            
            //Insert PCB into RQ;
            insertIntoRQ(pcbPointer);
            
            return;
        }

        //If no matching PCB is found in WQ print invalid pid as error message;
        System.out.printf("%n$ ERROR %d: PID %d is invalid.%n", SystemConstants.ERROR, pid);
    }

    //************************************************************
    // Function: interruptOutputCompletion
    //
    // Task Description:
    //    Reads PID of the process completing output completion interrupt (io_putc),
    //    searches WQ to find the PCB having the given PID,
    //    THEN prints the character in GPR1 of the process PCB. This is because the process is not
    //    running
    //    Finally, insert the process back into the ready queue to be dispatched and ran
    //
    // Input Parameters
    //    none
    //
    // Output Parameters
    //    ERROR                 PID is invalid
    //
    // Function Return Value
    //    none
    //************************************************************
    //Void ISRoutputCompletionInterrupt()
    public static void interruptOutputCompletion() {

        //Prompt and read PID of the process completing output completion interrupt;
        System.out.printf("%n$ Enter the PID of the process completing the output completion interrupt >>> ");
        long pid = input.nextLong();

        //Search WQ to find the PCB having the given PID
        long pcbPointer = searchAndRemovePCBFromWQ(pid);
        
        if (pcbPointer > 0) {
            //Print the character in the GPR in the PCB;
            char character = (char)Main.getHypoMemory(pcbPointer + SystemConstants.PCB_CONTEXT_GPR1); //Main.getGPR(1);
            System.out.printf("%nOutput >>> %c%n", character);

            //Set process state to Ready in the PCB;
            Main.setHypoMemory(pcbPointer + SystemConstants.PCB_STATE, SystemConstants.PROC_READY);

            //Insert PCB into RQ;
            insertIntoRQ(pcbPointer);

            return;
        }

        //If no matching PCB is found in WQ and RQ, print invalid pid as error message;
        System.out.printf("%n$ ERROR %d: PID %d is invalid.%n", SystemConstants.ERROR, pid);

        return;
    }

    //************************************************************
    // Function: interruptOutputCompletion
    //
    // Task Description:
    //    Terminate all processes in the ready queue AND waiting queue one by one
    //    Does this by setting the RQ or WQ pointer to the next PCB pointer stored in each PCB
    //    until it reaches EOL (last PCB entry has been reached)
    //    Along the way, each PCB is terminated using terminateProcess()
    //
    // Input Parameters
    //    none
    //
    // Output Parameters
    //    none
    //
    // Function Return Value
    //    none
    //************************************************************
    //Void ISRshutdownSystem()
    public static void interruptShutdownSystem() {
        // Terminate all processes in RQ one by one
        // set ptr to first PCB pointed by RQ
        long pointer = Main.getRQ();

        //while(ptr is not equal to End Of List)
        while (pointer != SystemConstants.END_OF_LIST) {
            //Set RQ = next PCB using ptr;
            Main.setRQ(Main.getHypoMemory(Main.getRQ() + SystemConstants.PCB_NEXT));

            //Call Terminate Process passing ptr as argument;
            terminateProcess(pointer);

            //Set ptr = RQ;
            pointer = Main.getRQ();
        }

        // Terminate all processed in WQ one by one
        //Code is similar to terminating processes in RQ given above.

        pointer = Main.getWQ();

        //while(ptr is not equal to End Of List)
        while (pointer != SystemConstants.END_OF_LIST) {
            //Set WQ = next PCB using ptr;
            Main.setWQ(Main.getHypoMemory(Main.getWQ() + SystemConstants.PCB_NEXT));

            //Call Terminate Process passing ptr as argument;
            terminateProcess(pointer);

            //Set ptr = WQ;
            pointer = Main.getWQ();
        }
    }



    // [ SPECIAL I/O METHODS ] //

    //************************************************************
    // Function: io_getcSystemCall + io_putcSystemCall
    //
    // Task Description:
    //    Simply return special codes which trigger CPU to pause and give control to the OS
    //
    // Input Parameters
    //    none
    //
    // Output Parameters
    //    none
    //
    // Function Return Value
    //    INT_INPUT_COMP                Input completion interrupt is occurring
    //    INT_OUTPUT_COMP               Output completion interrupt is occurring
    //************************************************************
    //long io_getcSystemCall ()
    public static long io_getcSystemCall() {
        //Return start of input operation event code;
        return SystemConstants.INT_INPUT_COMP;
    }

    //long io_putcSystemCall ()
    public static long io_putcSystemCall() {
        //Return start of output operation event code;
        return SystemConstants.INT_OUTPUT_COMP;
    }


    
    // [ TIME SET/GET METHODS ] //

    //************************************************************
    // Function: time_get
    //
    // Task Description:
    //    Retrieves CPU clock value and store in GPR1; GPR0 always OK
    //
    // Input Parameters
    //    none
    //
    // Output Parameters
    //    none
    //
    // Function Return Value
    //    none
    //************************************************************
    //time_get
    //retrieve CPU clock value and store in GPR1; GPR0 always OK
    public static void time_get() {
        Main.setGPR(0, SystemConstants.OK);
        Main.setGPR(1, Main.getPC());
    }

    //************************************************************
    // Function: time_set
    //
    // Task Description:
    //    Sets CPU clock to whatever is in GPR1; GPR0 always OK
    //
    // Input Parameters
    //    none
    //
    // Output Parameters
    //    none
    //
    // Function Return Value
    //    none
    //************************************************************
    //time_set
    //set CPU clock to whatever is in GPR1; GPR0 always OK
    public static void time_set() {
        Main.setGPR(0, SystemConstants.OK);
        Main.setPC(Main.getGPR(1));
    }
}